----QUIT----2020-01-22T20:54:30.239682+01:00 Pharo8.0-SNAPSHOT-32bit-0932da8.image priorSource: 0!----QUIT----2020-01-22T20:54:52.539489+01:00 Pharo8.0-SNAPSHOT-32bit-0932da8.image priorSource: 0!Object subclass: #Compteur	instanceVariableNames: 'valeur' "noms des attributs"	classVariableNames: '' "aucun attributs static"	category: 'TD-HAI931' "package"!!Compteur methodsFor: 'as yet unclassified' stamp: 'Anonymous 9/16/2024 15:42'!incr! !!Compteur methodsFor: 'as yet unclassified' stamp: 'Anonymous 9/16/2024 15:43' prior: 33554878!incr	valeur := valeur + 1 ! !!Compteur methodsFor: 'as yet unclassified' stamp: 'Anonymous 9/16/2024 15:45'!initialise	valeur := 0.! !!Compteur methodsFor: 'as yet unclassified' stamp: 'Anonymous 9/16/2024 15:46'!initialize	valeur := 0.! !!Compteur methodsFor: 'as yet unclassified' stamp: 'Anonymous 9/16/2024 15:48'!valeur 	"le return est le petit chapeau : ^"	^valeur! !Compteur removeSelector: #initialise!!Compteur methodsFor: 'as yet unclassified' stamp: 'Anonymous 9/16/2024 15:50'!decr	valeur := valeur + 1! !Object subclass: #Pile	instanceVariableNames: 'contenu index capacite' "noms des attributs"	classVariableNames: 'tailleDefaut' "noms des attributs statics"	category: 'TD-HAI931' "package"!!Pile methodsFor: 'as yet unclassified' stamp: 'Anonymous 9/16/2024 16:04'!initialize: taille "la pile est vide quand index = 0" index := 0. "la pile est pleine quand index = capacite" capacite := taille. "le contenu est stocké dans un tableau" contenu := Array new: capacite. "pour les tests, enlever le commentaire quand isEmpty est écrite" "self assert: (self isEmpty)."! !!Pile methodsFor: 'as yet unclassified' stamp: 'Anonymous 9/16/2024 16:11'!isEmpty	^index = 0.! !!Pile methodsFor: 'as yet unclassified' stamp: 'Anonymous 9/16/2024 16:13'!isFull 	^index = capacite.! !!Pile methodsFor: 'as yet unclassified' stamp: 'Anonymous 9/16/2024 16:14'!push: unObjet	"met anObject dans contenu au bon index si la pile n'est pas pleine"	self isFull		ifFalse: [			index := index + 1.			contenu at: index put: unObjet.]		ifTrue: [ self error: 'Impossible d''empiler sur une pile pleine' ]! !!Pile methodsFor: 'as yet unclassified' stamp: 'Anonymous 9/16/2024 16:15'!pop	"dépile et rend le sommet de pile si la pile n'est pas vide"	| retour |	self isEmpty		ifFalse: [			retour := contenu at: index.			index := index - 1.			^retour]		ifTrue: [ self error: 'Pile vide, Impossible de dépiler' ]! !!Pile methodsFor: 'as yet unclassified' stamp: 'Anonymous 9/16/2024 16:16'!top	"rend le sommet de pile si la pile n'est pas vide, sans dépiler"	self isEmpty		ifFalse: [ ^contenu at: index]		ifTrue: [ self error: 'Rien au sommet d''une pile vide' ]! !!Pile methodsFor: 'as yet unclassified' stamp: 'Anonymous 9/16/2024 16:20'!printOn: aStream aStream nextPutAll: 'une Pile, de taille: '. capacite printOn: aStream. aStream nextPutAll: ' contenant: '. index printOn: aStream. aStream nextPutAll: ' objets : ('. contenu do: [ :each | each printOn: aStream. aStream space ]. aStream nextPut: $). aStream nextPut: $.! !----SNAPSHOT----2024-09-16T16:26:52.831417+02:00 Pharo 8.0 - 64bit.image priorSource: 100!----SNAPSHOT----2024-09-16T16:26:57.088021+02:00 Pharo 8.0 - 64bit.image priorSource: 3136!----SNAPSHOT----2024-09-16T16:27:00.620052+02:00 Pharo 8.0 - 64bit.image priorSource: 3228!!RawObjTest commentStamp: 'StephaneDucasse 11/17/2014 11:09' prior: 0!These tests are based on a setup that does not rely on structure for the accessors.!!ObjClassInspector commentStamp: 'StephaneDucasse 11/16/2014 23:11' prior: 0!I'm a simple inspector that can inspect fixed structured Obj class."creating class by hand"| coloredPointClass |coloredPointClass := Obj new: 6.coloredPointClass at: coloredPointClass offsetForName put: #ObjColoredPoint.coloredPointClass at: coloredPointClass offsetForClass put: #ObjClass.coloredPointClass at: coloredPointClass offsetForIVs put: #( #class #x #y #color).coloredPointClass at: coloredPointClass offsetForSuperclass put: #ObjPoint.coloredPointClass at: coloredPointClass offsetForMethodDict	put: (IdentityDictionary new).coloredPointClass.ObjClassInspector basicInspect: coloredPointClass.!!ObjExampleTest class methodsFor: 'first user-defined metaclasses'!setMetaclassDefinition	"self setMetaclassDefinition"	| setClass |	setClass := Obj ObjClass				send: #new				withArguments: #(#(#name: #ObjSet #iv: #(#myInstances) #superclass: #ObjClass)).	"initialize on a metaclass"	setClass 		addMethod: #initialize		args: 'initArray'		withBody: 			'			objself binarySuper: #initialize with: initArray from: superClassOfClassDefiningTheMethod.			objself send: #setIV				withArguments: (Array with: #myInstances with: OrderedCollection new).			objself'.	setClass addUnaryMethod: #instances		withBody: 'objself binarySend: #getIV with: #myInstances'.	setClass addMethod: #new		args: 'initArray'		withBody: 			'| newInst others |			newInst := objself super: #new withArguments: (Array with: initArray) from: superClassOfClassDefiningTheMethod.			others := objself unarySend: #instances.			others := others add: newInst;						yourself.			objself send: #setIV withArguments: (Array with: #myInstances with: others).			newInst'! !!ObjExampleTest class methodsFor: 'first user-defined metaclasses' stamp: 'StephaneDucasse 11/26/2014 22:04'!setMetaclassExample	"self setMetaclassExample"	| memoPointClass |	self setMetaclassDefinition.	memoPointClass := Obj ObjSet 						send: #new						withArguments: #(#(#name: #ObjMemoPoint  #iv: #() #superclass: #ObjPoint)).	memoPointClass send: #new withArguments: #(#(#x: 24 #y: 6)).	memoPointClass send: #new withArguments: #(#(#x: 15 #y: 10)).	^memoPointClass send: #instances withArguments: #().! !!ObjExampleTest methodsFor: 'setup'!abstractMetaclassDefinition 	(Obj giveClassNamed: #ObjClass)					 		send: #new							withArguments: #(#(#name: #ObjAbstractClass #iv: #() #superclass: #ObjClass)).	Obj ObjAbstractClass 		addMethod: #new		args: 'initArray'		withBody: 			' objself error: '' the class '' , objself objName asString , '' is abstract'''! !!ObjExampleTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:52'!defineObjAbstractPoint	(Obj ObjAbstractClass)		send: #new		withArguments: #(#(#name: #ObjAbstractPoint #iv: #() #superclass: #ObjObject)).	Obj ObjAbstractPoint		addUnaryMethod: #givex		withBody: 'objself  valueOfInstanceVariable: #x '.	Obj ObjAbstractPoint 		addUnaryMethod: #display		withBody: 			'Transcript cr;				show: ''aPoint with x = ''.			Transcript show: (objself send: #givex withArguments: #()) printString;				cr'.! !!ObjExampleTest methodsFor: 'setup'!defineObjPoint	Obj ObjClass send: #new		withArguments: #(#(#name: #ObjPoint #iv: #(#x #y) #superclass: #ObjAbstractPoint)).! !!ObjExampleTest methodsFor: 'setup'!setUp	Obj bootstrap.	self abstractMetaclassDefinition.	self defineObjAbstractPoint.	self defineObjPoint! !!ObjExampleTest methodsFor: 'test abstract'!testAbstractMetaclassExample	self should: [Obj ObjAbstractClass send: #new withArguments: #(#(#x: 24 #y: 6))] raise: Error.! !!ObjExampleTest methodsFor: 'test abstract'!testAbstractMetaclassExampleWithConcreteSubclass	self shouldnt: [Obj ObjPoint send: #new withArguments: #(#(#x: 24 #y: 6))]		raise: Error! !!ObjExampleTest methodsFor: 'test abstract' stamp: 'StephaneDucasse 11/27/2014 20:48'!testColoredPoint	| coloredPointClass aColoredPoint |	coloredPointClass := (Obj ObjClass)						 	send: #new 							withArguments: #((#name: #ObjColoredPoint 							           		   #iv: #(#color) 							            	  #superclass: #ObjPoint)).	aColoredPoint := coloredPointClass send: #new withArguments: #((#x: 24 #y: 6 #color: #blue)).		"first messages sent"	self assert: (aColoredPoint send: #getIV withArguments: #(#x)) = 24.	aColoredPoint send: #setIV withArguments: #(#x 25).	self assert: (aColoredPoint send: #getIV withArguments: #(#x)) = 25.	self assert: (aColoredPoint send: #getIV withArguments: #(#color)) = #blue.		"adding some methods"	coloredPointClass 		addUnaryMethod: #giveColor		withBody: 'objself send: #getIV withArguments: #(#color)'.	coloredPointClass 		addMethod: #setColor		args: 'col'		withBody:' objself send: #setIV withArguments: (Array with: #color with: col)'.	coloredPointClass addUnaryMethod: #display		withBody:  			'objself super: #display withArguments: #() from: superClassOfClassDefiningTheMethod.			Transcript cr;				show: '' with Color = ''.			Transcript show: (objself send: #giveColor withArguments: #()) printString;				cr'.	self assert: (aColoredPoint send: #giveColor withArguments: #()) = #blue.		self assert: (aColoredPoint send: #givex withArguments: #()) = 25.		aColoredPoint send: #display withArguments: #().! !!ObjMessageTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/26/2014 15:33'!setUp	Obj bootstrap.	Obj objClassStructureMessage.! !!ObjMessageTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/26/2014 22:05'!testMessageClassMethods	"self debug: #testMessageClassMethods"		| msg |	Obj addMessagesForErrorHandling.	msg := Obj ObjMessage 				send: #new 				withArguments: #(#(#receiver: 24 #selector: #factorial)).		self assert: (msg send: #receiver2 withArguments: #()) equals: 24.	self assert: (msg send: #receiver withArguments: #()) equals: 24.	self assert: (msg send: #selector withArguments: #()) equals: #factorial.		msg := Obj ObjMessage 		send: #new 		withArguments: #(#(#receiver: 24 #selector: #+ arguments: #(25))).	self assert: (msg send: #arguments withArguments: #())  equals: #(25).! !!ObjMessageTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/20/2014 14:52'!testMessageClassMethodsDefined	"self debug: #testMessageClassMethodsDefined"		| msg |	Obj addMessagesForErrorHandling.	self deny: Obj ObjMessage objMethodDict size isZero! !!ObjMessageTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/20/2014 10:16'!testMessageClassStructureDeclared	Obj objClassStructureMessage.	self assert: Obj ObjMessage objName = #ObjMessage.	self assert: Obj ObjMessage objClass objName= #ObjClass.	self assert: Obj ObjMessage objIVs asArray = #(#class #receiver #selector #arguments).	self assert: Obj ObjMessage objSuperclass = Obj ObjObject	! !!ObjMessageTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/20/2014 15:05'!testUsingPrimitivesMessageClassMethods	| msg |	msg := Obj ObjMessage 		send: #new 		withArguments: #(#(#receiver: 24 #selector: #factorial)).		self assert: (msg at: 1) equals: #ObjMessage.	self assert: (msg at: 2) equals: 24.	self assert: (msg at: 3) equals: #factorial.		msg := Obj ObjMessage 		send: #new 		withArguments: #(#(#receiver: 24 #selector: #+ arguments: #(25))).	self assert: (msg at: 4)  equals: #(25).! !!ObjTest methodsFor: 'setup'!assembleClassClass	classClass := Obj new: 6.	classClass at: classClass offsetForName put: #ObjClass.	classClass at: classClass offsetForClass put: #ObjClass.	classClass at: classClass offsetForIVs		put: #(#class #name #superclass #iv #keywords #methodDict).	classClass at: classClass offsetForKeywords		put: #(#name: #superclass: #iv: #keywords: #methodDict:).	classClass at: classClass offsetForSuperclass put: #ObjObject.	classClass at: classClass offsetForMethodDict		put: (IdentityDictionary new).	Obj declareClass: classClass! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 10/22/2009 16:24'!assembleColoredInstance	aColoredPoint := Obj new: 4.	aColoredPoint at: 1 put: #ObjColoredPoint.	aColoredPoint at: 2 put: 10.	aColoredPoint at: 3 put: 15.	aColoredPoint at: 4 put: #blue! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:36'!assembleColoredPointClass	coloredPointClass := Obj new: 6.	coloredPointClass at: pointClass offsetForName put: #ObjColoredPoint.	coloredPointClass at: pointClass offsetForClass put: #ObjClass.		"Here the initialize of metaclass is not available so we perform the instance variable lookup by hand."	coloredPointClass at: pointClass offsetForIVs put: #( #class #x #y #color).	coloredPointClass at: pointClass offsetForSuperclass put: #ObjPoint.	coloredPointClass at: pointClass offsetForMethodDict		put: (IdentityDictionary new).	Obj declareClass: coloredPointClass.	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'I''am a colored point';				cr]] value: pointClass).	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod)				]] value: pointClass).	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #bar		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #bar withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #bar withArguments:#() from: superClassOfClassDefiningTheMethod)]			] value: pointClass).! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 2/15/2011 16:10'!assembleIncrementalColoredInstance		aIncrementalColoredPoint := Obj new: 4.	aIncrementalColoredPoint at: 1 put: #ObjIncrementalColoredPoint.	aIncrementalColoredPoint at: 2 put: 10.	aIncrementalColoredPoint at: 3 put: 15.	aIncrementalColoredPoint at: 4 put: #blue! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:37'!assembleIncrementalColoredPointClass	incrementalColoredPointClass := Obj new: 6.	incrementalColoredPointClass at: pointClass offsetForName put: #ObjIncrementalColoredPoint.	incrementalColoredPointClass at: pointClass offsetForClass put: #ObjClass.		"Some tests will invoke by hand computeIV... so we do not have to hardcode the sequence."	incrementalColoredPointClass at: pointClass offsetForIVs put: #( #color).	incrementalColoredPointClass at: pointClass offsetForSuperclass put: #ObjPoint.	incrementalColoredPointClass at: pointClass offsetForMethodDict		put: (IdentityDictionary new).	Obj declareClass: incrementalColoredPointClass.	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'I''am a colored point';				cr]] value: pointClass).	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod)				]] value: pointClass).	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #bar		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #bar withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #bar withArguments: #() from: superClassOfClassDefiningTheMethod)]			] value: pointClass).! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/26/2014 16:01'!assembleObjectClass	objectClass := Obj new: 6.	objectClass at: objectClass offsetForName put: #ObjObject.	objectClass at: objectClass offsetForClass put: #ObjClass.	objectClass at: objectClass offsetForIVs put: #(#class).	objectClass at: objectClass offsetForKeywords put: #().	objectClass at: objectClass offsetForSuperclass put: nil.	objectClass at: objectClass offsetForMethodDict put: (IdentityDictionary new).	Obj declareClass: objectClass.	"here I simulate by hand the way superclass is captured for super lookup, I value the block with nil for now to represent	the superclass of ObjObject"	(objectClass at: objectClass offsetForMethodDict) at: #print		put: 			([:superClassOfClassDefiningTheMethod |				[:objself | 			Transcript show: 'I''am an Object';				cr]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #error		put: 			([:superClassOfClassDefiningTheMethod |				[:object :arrayOfArguments | 			Transcript show: 'Error: selector ' , arrayOfArguments first printString , ' not understood';				cr.				Error signal]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #getIV		put: ([:superClassOfClassDefiningTheMethod | [:object :iv | object valueOfInstanceVariable: iv]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #setIV		put: 			([:superClassOfClassDefiningTheMethod | [:object :iv :val | 			object at: (object offsetFromObjectOfInstanceVariable: iv) put: val]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #bar		put: 			([:superClassOfClassDefiningTheMethod | [:objself | 					5]] value: nil).! !!ObjTest methodsFor: 'setup'!assemblePointClass	| cl |	cl := Obj giveClassNamed: #ObjClass.	pointClass := Obj new: (cl at: cl offsetForIVs) size.	pointClass at: pointClass offsetForName put: #ObjPoint.	pointClass at: pointClass offsetForClass put: #ObjClass.	pointClass at: pointClass offsetForIVs put: #(#class #x #y).	pointClass at: pointClass offsetForKeywords put: #(#x: #y:).	pointClass at: pointClass offsetForSuperclass put: #ObjObject.	pointClass at: pointClass offsetForMethodDict		put: (IdentityDictionary new).	Obj declareClass: pointClass.	(pointClass at: pointClass offsetForMethodDict) at: #x		put: ([ :superClassOfClassDefiningTheMethod | [:objself | objself valueOfInstanceVariable: #x]] value: objectClass).	(pointClass at: pointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | [:objself | 			Transcript show: 'I''am a Point';				cr]] value: objectClass).	(pointClass at: pointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'ObjPoint>>foo';cr.				5				]] value: objectClass)! !!ObjTest methodsFor: 'setup'!assemblePointInstance	aPoint := Obj new: 3.	aPoint at: 1 put: #ObjPoint.	aPoint at: 2 put: 10.	aPoint at: 3 put: 15! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 2/15/2011 16:15'!setUp	"self new setUp"	Obj initialize.	self assembleClassClass.	self assemblePointClass.	self assembleObjectClass.	self assembleColoredPointClass.	self assemblePointInstance.	self assembleColoredInstance.	self assembleIncrementalColoredInstance.	self assembleIncrementalColoredPointClass! !!ObjTest methodsFor: 'step5-tests-allocate' stamp: 'StephaneDucasse 11/21/2015 15:44'!testAllocate  "(self  selector: #testAllocate) run"  | newInstance |  newInstance := pointClass allocateAnInstance.  self assert: (newInstance at: 1) = #ObjPoint.  self assert: (newInstance size) = 3.  self assert: (newInstance at: 2) isNil.  self assert: (newInstance at: 3) isNil.  self assert: (newInstance objClass = pointClass)! !!ObjTest methodsFor: 'utilities tests'!testBlockArgsFrom	self assert: (Obj new blockArgsFrom: ' abc def ghi ')  = ':abc :def :ghi'.	self assert: (Obj new blockArgsFrom: 'abc def ghi')  = ':abc :def :ghi'.	self assert: (Obj new blockArgsFrom: '')  = ''.! !!ObjTest methodsFor: 'utilities tests' stamp: 'NicoPAez 10/21/2010 10:22'!testBlockBodyFromHeaderAndBody	"a method with one argument: val"	self assert: (Obj new stringOfBlockBodyFromHeader: 'val' andBody: 'objself send: #setIV 										 withArguments: (Array with: #x with: val).')										= '[ :superClassOfClassDefiningTheMethod |		[ :objself :val |					 objself send: #setIV 										 withArguments: (Array with: #x with: val).] ]'.	"a method without arg"	self assert: (Obj new stringOfBlockBodyFromHeader: '' andBody: 'objself unarySend: #getx.') 	='[ :superClassOfClassDefiningTheMethod |		[ :objself  |					 objself unarySend: #getx.] ]'	! !!ObjTest methodsFor: 'step3-tests-class access'!testClassAccess	"(self  selector: #testClassAccess) run"		self assert: (aPoint objClass = pointClass)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:52'!testErrorRaisedSendWhenErrorInLookup	"(self  selector: #testErrorRaisedSendWhenErrorInLookup) run"		self should: [  pointClass sendError: #zork withArgs: { aPoint } ] raise: Error.	"Open a Transcript to see the message trace"! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/27/2014 21:15'!testErrorRedefinition	"(self  run: #testErrorRedefinition)"		self should: [aPoint send: #zork withArguments: #()] raise: Error.	(pointClass at: pointClass offsetForMethodDict) at: #error		put: ([ :superClassOfClassDefiningTheMethod | [:objself :selector | 33]] value: objectClass).		self assert: (aPoint send: #zork withArguments: #()) = 33.	(pointClass at: pointClass offsetForMethodDict) at: #error		put: ([ :superClassOfClassDefiningTheMethod | [:objself :selector | 33]] value: objectClass).	self assert: (aPoint send: #zork withArguments: #(44)) = 33.! !!ObjTest methodsFor: 'step4-tests-iv management'!testIVOffset	"(self  selector: #testIVOffset) run"	self assert: ((pointClass offsetFromClassOfInstanceVariable: #x ) = 2).	self assert: ((pointClass offsetFromClassOfInstanceVariable: #lulu ) = 0)! !!ObjTest methodsFor: 'step4-tests-iv management'!testIVOffsetAndValue	"(self  selector: #testIVOffsetAndValue) run"	self assert: ((aPoint offsetFromObjectOfInstanceVariable: #x ) = 2).	self assert: ((aPoint valueOfInstanceVariable: #x ) = 10)! !!ObjTest methodsFor: 'step7-tests-initialize' stamp: 'StephaneDucasse 11/21/2015 16:16'!testInitialize	"(self  selector: #testInitialize) run"	| newInstance  |	newInstance := pointClass allocateAnInstance.	newInstance initializeUsing: #(#y: 2 #z: 3 #t: 55 #x: 1).	self assert: (newInstance at: 1) equals: #ObjPoint.	self assert: (newInstance at: 2) equals: 1.	self assert: (newInstance at: 3) equals: 2.! !!ObjTest methodsFor: 'step8-tests-instance variable inheritance'!testInstanceVariableInheritance	"(self  selector: #testInstanceVariableInheritance) run"	"a better choice would be to throw an exception if there are duplicates"	self assert: 			((Obj new computeNewIVFrom: #(#a #b #c #d) asOrderedCollection				with: #(#a #z #b #t) asOrderedCollection)					= #(#a #b #c #d #z #t) asOrderedCollection).	self assert: 			((Obj new computeNewIVFrom: #() asOrderedCollection				with: #(#a #z #b #t) asOrderedCollection)					= #(#a #z #b #t) asOrderedCollection)! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables' stamp: 'StephaneDucasse 2/15/2011 16:12'!testInstanceVariableInheritanceFromAClass	"(self  selector: #testInstanceVariableInheritanceFromAClass) run"		aIncrementalColoredPoint objClass objIVs: (aIncrementalColoredPoint computeNewIVFrom: aPoint objClass objIVs  with: aIncrementalColoredPoint objClass objIVs).		self assert: ((pointClass offsetFromClassOfInstanceVariable: #x ) = 2).	self assert: ((incrementalColoredPointClass offsetFromClassOfInstanceVariable: #x ) = 2).	! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables' stamp: 'StephaneDucasse 2/15/2011 16:14'!testInstanceVariableInheritanceFromAObject	"(self  selector: #testInstanceVariableInheritanceFromAObject) run"		aIncrementalColoredPoint objClass objIVs: (aIncrementalColoredPoint computeNewIVFrom: aPoint objClass objIVs  with: aIncrementalColoredPoint objClass objIVs).		self assert: ((aPoint offsetFromObjectOfInstanceVariable: #x ) = 2).	self assert: ((aIncrementalColoredPoint offsetFromObjectOfInstanceVariable: #x ) = 2).			! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables' stamp: 'JB 10/9/2009 16:52'!testInstanceVariableInheritanceNotFind	"(self  selector: #testInstanceVariableInheritanceNotFind) run"		self should: [aPoint offsetFromObjectOfInstanceVariable: #zork ] raise: Error.			! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables' stamp: 'JB 10/13/2009 16:23'!testInstanceVariableInheritanceNumberOfInstanceVar	"(self  selector: #testInstanceVariableInheritanceNumberOfInstanceVar) run"		self assert: ((pointClass numberOfIVs ) = 3).	self assert: ((coloredPointClass numberOfIVs ) = 4).	! !!ObjTest methodsFor: 'step6-tests-keywords'!testKeywords	"(self  selector: #testKeywords) run"	| dummyObject |	dummyObject := Obj new.	self assert: 			((dummyObject generateKeywords: #(#titi #toto #lulu))				= #(#titi: #toto: #lulu:)).	self assert: 			((dummyObject keywordValue: #x				getFrom: #(#toto 33 #x 23)				ifAbsent: 2) = 23).	self assert: 			((dummyObject keywordValue: #x				getFrom: #(#toto 23)				ifAbsent: 2) = 2).	self assert: 			((dummyObject returnValuesFrom: #(#x 22 #y 35) followingSchema: #(#y #yy #x #y))				= #(35 nil 22 35))! !!ObjTest methodsFor: 'tests'!testMethodDefinition	"(self  selector: #testMethodManagment) run"	self assert: (pointClass doesUnderstand: #x).	self assert: (pointClass doesUnderstand: #xx) not.	"define a unary method xx returning the receiver."	pointClass 		addMethod: #xx		args: ''		withBody: 'objself'.	self assert: (pointClass doesUnderstand: #xx).	self assert: (((pointClass bodyOfMethod: #xx) value: 22) = 22).	"define a unary method returning the slot x of the receiver"	pointClass 		addMethod: #getgetx		args: ''		withBody: 'objself valueOfInstanceVariable: #x'.	self assert: (pointClass doesUnderstand: #getgetx).	self assert: (((pointClass bodyOfMethod: #getgetx) value: aPoint) = 10).! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 12/5/2014 17:37'!testMethodLookup	"(self  selector: #testMethodLookup) run"		self assert: ((pointClass lookup: #x) isKindOf: BlockClosure)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:37'!testMethodLookupFindSimpleMethod	"(self  selector: #testMethodLookupFindSimpleMethod) run"	self assert: ((pointClass lookup: #x)  isKindOf: BlockClosure)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:37'!testMethodLookupFindSuperMethod	"(self  selector: #testMethodLookupFindSuperMethod) run"		self assert: ((coloredPointClass lookup: #x) isKindOf: BlockClosure)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:38'!testMethodLookupStop	"(self  selector: #testMethodLookupStop) run"		| foundMethod|	foundMethod := (pointClass lookup: #zork).	self assert: foundMethod isNil. 	"The method zork is NOT implement on pointClass, so nil is returned."	self should: [ pointClass sendError: #error withArgs: {aPoint}] raise: Error.		foundMethod := (pointClass lookup: #error).	self assert: (foundMethod isKindOf: BlockClosure).	self assert: ('*Error*' match: foundMethod printString).		"the message error defined on ObjObject requires two arguments: an object and a selector and it raises 	an error when executed. Open a Transcript to see the message trace"	self should:  [((pointClass lookup: #zork) value: 'r' value: #e)] raise: Error .! !!ObjTest methodsFor: 'tests' stamp: 'NicoPAez 10/21/2010 10:25'!testMethodManagement	"(self  selector: #testMethodManagment) run"	self assert: (pointClass doesUnderstand: #x).	self assert: (pointClass doesUnderstand: #xx) not.		pointClass 		addMethod: #xx		args: ''		withBody: 'objself valueOfInstanceVariable: #x '.	self assert: (((pointClass bodyOfMethod: #xx) value: aPoint) = 10).	self assert: (pointClass doesUnderstand: #xx).	pointClass removeMethod: #xx.	self assert: (pointClass doesUnderstand: #xx) not.	self assert: (((pointClass bodyOfMethod: #x) value: aPoint) = 10)! !!ObjTest methodsFor: 'tests-MethodsManagement' stamp: 'JB 10/9/2009 16:51'!testMethodManagmentAddRemoveMethods	"(self  selector: #testMethodManagmentAddRemoveMethods) run"	pointClass 		addMethod: #xx		args: ''		withBody: 'objself valueOfInstanceVariable: #x '.	self assert: (((pointClass bodyOfMethod: #xx) value: aPoint) = 10).	self assert: (pointClass doesUnderstand: #xx).	pointClass removeMethod: #xx.	self assert: (pointClass doesUnderstand: #xx) not.	self assert: (((pointClass bodyOfMethod: #x) value: aPoint) = 10)! !!ObjTest methodsFor: 'tests-MethodsManagement' stamp: 'JB 10/9/2009 16:51'!testMethodManagmentBodyOfMethod	"(self  selector: #testMethodManagmentBodyOfMethod) run"		self assert: (((pointClass bodyOfMethod: #x) value: aPoint) = 10)! !!ObjTest methodsFor: 'tests-MethodsManagement' stamp: 'JB 10/9/2009 16:52'!testMethodManagmentNotUnderstandBadMethod	"(self  selector: #testMethodManagmentNotUnderstandBadMethod) run"	self assert: (pointClass doesUnderstand: #xx) not.	! !!ObjTest methodsFor: 'tests-MethodsManagement' stamp: 'JB 10/9/2009 16:52'!testMethodManagmentUnderstandGoodMethod	"(self  selector: #testMethodManagmentUnderstandGoodMethod) run"	self assert: (pointClass doesUnderstand: #x).! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/26/2014 22:05'!testMethodNotFoundRaiseError	"(self  run: #testMethodNotFoundRaiseError)"	self should: [aPoint send: #zork withArguments: #()] raise: Error.! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/27/2014 12:18'!testMethodSelfSend	"(self  selector: #testMethodSelfSend) run"	"method found in the class PointClass"	self assert: ((aPoint send: #x withArguments: #()) = 10).	"method found in ObjClass"	self assert: ((aPoint send: #getIV withArguments: #(#x)) = 10).	"method found in ObjClass"	aPoint send: #setIV withArguments: #(y 22).	self assert: ((aPoint send: #getIV withArguments: #(#y)) = 22)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 11/26/2014 22:22'!testMethodSelfSendUnarySend	"(self  selector: #testMethodSelfSendUnarySend) run"	"method found in the class PointClass"	self assert: ((aPoint send: #x withArguments: #()) = 10).	"method found in the class PointClass"	self assert: ((aColoredPoint send: #x withArguments:#()) = 10).! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/26/2014 22:22'!testMethodSuperCall	"(self  selector: #testMethodSuperCall) run"	"foo in point return 5"	self assert: ((aPoint send: #foo withArguments: #()) = 5).	"foo in colored point is doing super foo + super foo"	self assert: ((aColoredPoint send: #foo withArguments: #()) = 10).! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/26/2014 22:23'!testMethodSuperCallOverBigHierarchy	"(self  selector: #testMethodSuperCallOverBigHierarchy) run"	"bar is defined in Object and not on Point"	self assert: (aPoint send: #bar withArguments: #()) = 5.	"bar on coloredPoint = super bar + super bar"	self assert: (aColoredPoint send: #bar withArguments: #()) = 10.! !!ObjTest methodsFor: 'utilities tests'!testMethodWithHeaderAndBody	"a method simply returning objself"	self assert: ((pointClass					methodWithHeader: ''					andBody: 'objself ') value: 2) = 2.		"a method returning its first none implicit arg"	self assert: ((pointClass 					methodWithHeader: 'val'					andBody: 'val ') value: 2 value: 33) = 33.	"a method returns its superclass of the class defining the method value"	"this anonymous method is defined in pointClass so its superclass pointer is objectClass"	self assert: ((pointClass 					methodWithHeader: ''					andBody: ' superClassOfClassDefiningTheMethod ') value: aPoint) = objectClass .	self assert: ((coloredPointClass 					methodWithHeader: ''					andBody: ' superClassOfClassDefiningTheMethod ') value: aPoint) = pointClass .! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:52'!testNilWhenErrorInLookup	"(self  selector: #testNilWhenErrorInLookup) run"		self assert: (pointClass lookup: #zork) isNil.	"The method zork is NOT implement on pointClass"	! !!ObjTest methodsFor: 'tests' stamp: 'SD 2/5/2013 16:47'!testPrimitiveStructure	"(self selector: #testPrimitiveStructure) run"		self assert: (pointClass objClassId = #ObjClass).	self assert: ((pointClass objName ) = #ObjPoint).	self assert: ((pointClass objSuperclassId ) = #ObjObject).	self assert: ((pointClass objIVs) = #(#class #x #y)).	self assert: ((pointClass objKeywords) = #(#x: #y:)).	self assert: ((pointClass objMethodDict) = nil) not! !!ObjTest methodsFor: 'step1-tests-structure of objects' stamp: 'JB 10/9/2009 10:30'!testPrimitiveStructureObjClassId	"(self selector: #testPrimitiveStructureObjClassId) run"	self assert: (pointClass objClassId = #ObjClass).! !!ObjTest methodsFor: 'step1-tests-structure of objects' stamp: 'SD 2/5/2013 16:48'!testPrimitiveStructureObjClassIdForSimpleObject	"self run: #testPrimitiveStructureObjClassIdForSimpleObject"	self assert: (aPoint objClassId = #ObjPoint).! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:30'!testPrimitiveStructureObjIVs	"(self selector: #testPrimitiveStructureObjIVs) run"	self assert: ((pointClass objIVs) = #(#class #x #y)).! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:30'!testPrimitiveStructureObjKeywords	"(self selector: #testPrimitiveStructureObjKeywords) run"	self assert: ((pointClass objKeywords) = #(#x: #y:)).! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:29'!testPrimitiveStructureObjMethodDict	"(self selector: #testPrimitiveStructureObjMethodDict) run"	self assert: ((pointClass objMethodDict) = nil) not! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:29'!testPrimitiveStructureObjName	"(self selector: #testPrimitiveStructureObjName) run"	self assert: ((pointClass objName ) = #ObjPoint).	! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:29'!testPrimitiveStructureObjSuperclassId	"(self selector: #testPrimitiveStructureObjSuperclassId) run"	self assert: ((pointClass objSuperclassId ) = #ObjObject).! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 11/21/2015 18:24'!testRaisesErrorSendWhenErrorInLookup	"(self  selector: #testRaisesErrorSendWhenErrorInLookup) run"	self should: [ pointClass send: #zork withArguments: { aPoint } ] raise: Error.	"Open a Transcript to see the message trace"! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:54'!testSendErrorRaisesErrorSendWhenErrorInLookup	"(self  selector: #testSendErrorRaisesErrorSendWhenErrorInLookup) run"		self should: [  pointClass sendError: #zork withArgs: { aPoint } ] raise: Error.	"Open a Transcript to see the message trace"! !!ObjTestBootstrap methodsFor: 'test ObjClass creation' stamp: 'StephaneDucasse 11/26/2014 21:56'!testCreateObjClassMessage	"(self selector: #testCreateObjClassMessage) run"	| objClass |	Obj bootstrap.	objClass := Obj giveClassNamed: #ObjClass.	self assert: ((objClass send: #class withArguments: #()) = (Obj giveClassNamed: #ObjClass)).	self assert: (objClass send: #isClass withArguments: #()).	self assert: (objClass send: #isMetaclass withArguments: #())! !!ObjTestBootstrap methodsFor: 'test ObjClass creation' stamp: 'StephaneDucasse 11/26/2014 21:57'!testCreateObjClassStructure	"(self selector: #testCreateObjClassStructure) run"	| objClass |	Obj bootstrap.	objClass := Obj giveClassNamed: #ObjClass.	self assert: (objClass objName = #ObjClass).	self assert: (objClass objClassId = #ObjClass).	self assert: (objClass objSuperclassId = #ObjObject).	self assert: (objClass objIVs asArray = #(#class #name #superclass #iv #keywords #methodDict)).	self assert: (objClass objKeywords asArray = #(#name: #superclass: #iv: #keywords: #methodDict:))! !!ObjTestBootstrap methodsFor: 'test ObjObject creation ' stamp: 'StephaneDucasse 11/26/2014 21:59'!testCreateObjObjectInstanceMessage	"(self selector: #testCreateObjObjectInstanceMessage) run"	| pointClass objClass pointInstance |	Obj initialize.	Obj manuallyCreateObjClass.	Obj createObjObject.	objClass := Obj giveClassNamed: #ObjClass.	pointClass := objClass 							send: #new							withArguments: #(#(#name: #ObjPoint #superclass: #ObjObject #iv: #(#x #y))).	pointInstance := pointClass send: #new withArguments: #(#()).	self assert: (pointInstance objClassId = #ObjPoint).	self assert: ((pointInstance send: #getIV withArguments: #(#x)) = nil).	pointInstance send: #setIV withArguments: #(#x 25).	self assert:  ((pointInstance send: #getIV withArguments: #(x)) = 25 )! !!ObjTestBootstrap methodsFor: 'test ObjObject creation ' stamp: 'StephaneDucasse 11/26/2014 22:00'!testCreateObjObjectMessage	"(self selector: #testCreateObjObjectMessage) run"	| objObject |	Obj initialize.	Obj manuallyCreateObjClass.	Obj createObjObject.	objObject := Obj giveClassNamed: #ObjObject.	self assert: (objObject send: #class withArguments: #()) = (Obj giveClassNamed: #ObjClass).	self assert: (objObject send: #isClass withArguments: #()) not.	self assert: (objObject send: #getIV withArguments: #(#class)) = #ObjClass! !!ObjTestBootstrap methodsFor: 'test ObjObject creation ' stamp: 'stephane.ducasse 9/29/2008 14:32'!testCreateObjObjectStructure	"(self selector: #testCreateObjObjectStructure) run"	| objObject |	Obj initialize.	Obj manuallyCreateObjClass.	Obj createObjObject.	objObject := Obj giveClassNamed: #ObjObject.	self assert: (objObject objName = #ObjObject).	self assert: (objObject objClassId = #ObjClass).	self assert: (objObject objSuperclassId isNil).	self assert: (objObject objIVs asArray = #(#class)).	self assert: (objObject objKeywords asArray = #())! !!ObjTestBootstrap methodsFor: 'test ObjClass manual creation ' stamp: 'StephaneDucasse 11/26/2014 22:01'!testManuallyCreateObjClassAllocate	"(self selector: #testManuallyCreateObjClassAllocate) run"	| objClass emptyClass |	Obj initialize.	Obj manuallyCreateObjClass.	objClass := Obj giveClassNamed: #ObjClass.	emptyClass := objClass send: #allocate withArguments: #().	self assert: emptyClass objClassId = #ObjClass.	self assert:  emptyClass objSuperclassId isNil.	self assert:  emptyClass objIVs isNil.	self assert:  emptyClass objKeywords isNil.	self assert:  emptyClass objMethodDict isNil.	self assert:  emptyClass objName isNil! !!ObjTestBootstrap methodsFor: 'test ObjClass manual creation ' stamp: 'StephaneDucasse 11/26/2014 22:01'!testManuallyCreateObjClassStructure	"(self selector: #testManuallyCreateObjClassStructure) run"	| objClass |	Obj initialize.	Obj manuallyCreateObjClass.	objClass := Obj giveClassNamed: #ObjClass.	self assert: (objClass objName = #ObjClass).	self assert: (objClass objClassId = #ObjClass).	self assert: (objClass objClass == objClass).	self assert: (objClass objSuperclassId = #ObjObject).		"the fact that the created first class inherits form ObjObject is not necessary	because there is no super calls"	self assert: (objClass objIVs = #(#class #name #superclass #iv #keywords #methodDict)).	self assert: (objClass objKeywords = #(#name: #superclass: #iv: #keywords: #methodDict:))! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:10'!assembleClassClass	classClass := Obj new: 6.	classClass at: 2 put: #ObjClass.	classClass at: 1 put: #ObjClass.	classClass at: 4 put: #(#class #name #superclass #iv #keywords #methodDict).	classClass at: 5 put: #(#name: #superclass: #iv: #keywords: #methodDict:).	classClass at: 3 put: #ObjObject.	classClass at: 6 put: (IdentityDictionary new).	Obj declareClass: classClass! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:09'!assembleColoredInstance	aColoredPoint := Obj new: 4.	aColoredPoint at: 1 put: #ObjColoredPoint.	aColoredPoint at: 2 put: 10.	aColoredPoint at: 3 put: 15.	aColoredPoint at: 4 put: #blue! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:38'!assembleColoredPointClass	coloredPointClass := Obj new: 6.	coloredPointClass at: 2 put: #ObjColoredPoint.	coloredPointClass at: 1 put: #ObjClass.	"Here the initialize of metaclass is not available so we perform the instance variable lookup by hand."	coloredPointClass at: 4 put: #( #class #x #y #color).	coloredPointClass at: 3 put: #ObjPoint.	coloredPointClass at: 6 put: (IdentityDictionary new).	Obj declareClass: coloredPointClass.	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'I''am a colored point';				cr]] value: pointClass).	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #foo withArguments:#() from: superClassOfClassDefiningTheMethod) + (objself super: #foo withArguments:#() from: superClassOfClassDefiningTheMethod)				]] value: pointClass).	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #bar		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #bar withArguments:#() from: superClassOfClassDefiningTheMethod) + (objself super: #bar withArguments:#() from: superClassOfClassDefiningTheMethod)]			] value: pointClass).! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:09'!assembleIncrementalColoredInstance		aIncrementalColoredPoint := Obj new: 4.	aIncrementalColoredPoint at: 1 put: #ObjIncrementalColoredPoint.	aIncrementalColoredPoint at: 2 put: 10.	aIncrementalColoredPoint at: 3 put: 15.	aIncrementalColoredPoint at: 4 put: #blue! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:39'!assembleIncrementalColoredPointClass	incrementalColoredPointClass := Obj new: 6.	incrementalColoredPointClass at: 2 put: #ObjIncrementalColoredPoint.	incrementalColoredPointClass at: 1 put: #ObjClass.	"Some tests will invoke by hand computeIV... so we do not have to hardcode the sequence."	incrementalColoredPointClass at: 4 put: #( #color).	incrementalColoredPointClass at: 3 put: #ObjPoint.	incrementalColoredPointClass at: 6 put: (IdentityDictionary new).	Obj declareClass: incrementalColoredPointClass.	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'I''am a colored point';				cr]] value: pointClass).	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod)				]] value: pointClass).	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #bar		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #bar withArguments: #()  from: superClassOfClassDefiningTheMethod) + (objself super: #bar withArguments: #()  from: superClassOfClassDefiningTheMethod)]			] value: pointClass).! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:12'!assembleObjectClass	objectClass := Obj new: 6.	objectClass at: 2 put: #ObjObject.	objectClass at: 1 put: #ObjClass.	objectClass at: objectClass offsetForIVs put: #(#class).	objectClass at: objectClass offsetForKeywords put: #().	objectClass at: objectClass offsetForSuperclass put: nil.	objectClass at: objectClass offsetForMethodDict put: (IdentityDictionary new).	Obj declareClass: objectClass.	"here I simulate by hand the way superclass is captured for super lookup, I value the block with nil for now to represent	the superclass of ObjObject"	(objectClass at: objectClass offsetForMethodDict) at: #print		put: 			([:superClassOfClassDefiningTheMethod |				[:objself | 			Transcript show: 'I''am an Object';				cr]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #error		put: 			([:superClassOfClassDefiningTheMethod |				[:object :selector | 			Transcript show: 'Error: selector ' , selector printString , ' not understood';				cr.				Error signal]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #getIV		put: ([:superClassOfClassDefiningTheMethod | [:object :iv | object valueOfInstanceVariable: iv]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #setIV		put: 			([:superClassOfClassDefiningTheMethod | [:object :iv :val | 			object at: (object offsetFromObjectOfInstanceVariable: iv) put: val]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #bar		put: 			([:superClassOfClassDefiningTheMethod | [:objself | 					5]] value: nil).! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:13'!assemblePointClass	| cl |	cl := Obj giveClassNamed: #ObjClass.	pointClass := Obj new: (cl at: cl offsetForIVs) size.	pointClass at: 2 put: #ObjPoint.	pointClass at: 1 put: #ObjClass.	pointClass at: 4 put: #(#class #x #y).	pointClass at: 5 put: #(#x: #y:).	pointClass at: 3 put: #ObjObject.	pointClass at: 6 put: (IdentityDictionary new).	Obj declareClass: pointClass.	(pointClass at: pointClass offsetForMethodDict) at: #x		put: ([ :superClassOfClassDefiningTheMethod | [:objself | objself valueOfInstanceVariable: #x]] value: objectClass).	(pointClass at: pointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | [:objself | 			Transcript show: 'I''am a Point';				cr]] value: objectClass).	(pointClass at: pointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'ObjPoint>>foo';cr.				5				]] value: objectClass)! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:09'!assemblePointInstance	aPoint := Obj new: 3.	aPoint at: 1 put: #ObjPoint.	aPoint at: 2 put: 10.	aPoint at: 3 put: 15! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:09'!setUp	"self new setUp"	Obj initialize.	self assembleClassClass.	self assemblePointClass.	self assembleObjectClass.	self assembleColoredPointClass.	self assemblePointInstance.	self assembleColoredInstance.	self assembleIncrementalColoredInstance.	self assembleIncrementalColoredPointClass! !!RawObjTest methodsFor: 'step3-tests-class access' stamp: 'StephaneDucasse 11/17/2014 11:09'!testClassAccess	"(self  selector: #testClassAccess) run"		self assert: (aPoint objClass = pointClass)! !!RawObjTest methodsFor: 'step1-tests-structure of objects' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjClassId	"(self selector: #testPrimitiveStructureObjClassId) run"	self assert: (pointClass objClassId = #ObjClass).! !!RawObjTest methodsFor: 'step1-tests-structure of objects' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjClassIdForSimpleObject	"self run: #testPrimitiveStructureObjClassIdForSimpleObject"	self assert: (aPoint objClassId = #ObjPoint).! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjIVs	"(self selector: #testPrimitiveStructureObjIVs) run"	self assert: ((pointClass objIVs) = #(#class #x #y)).! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjKeywords	"(self selector: #testPrimitiveStructureObjKeywords) run"	self assert: ((pointClass objKeywords) = #(#x: #y:)).! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjMethodDict	"(self selector: #testPrimitiveStructureObjMethodDict) run"	self assert: ((pointClass objMethodDict) = nil) not! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjName	"(self selector: #testPrimitiveStructureObjName) run"	self assert: ((pointClass objName ) = #ObjPoint).	! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjSuperclassId	"(self selector: #testPrimitiveStructureObjSuperclassId) run"	self assert: ((pointClass objSuperclassId ) = #ObjObject).! !!Obj class methodsFor: 'bootstrap objMessage' stamp: 'StephaneDucasse 1/1/2018 20:14'!addMessagesForErrorHandling	"pre condition message has been created (and declared)"	"self addMessagesForErrorHandling"	| objMessage |	objMessage := self ObjMessage.	objMessage 		addUnaryMethod: #receiver 		withBody: 'objself valueOfInstanceVariable: #receiver'.	objMessage 		addUnaryMethod: #receiver2 		withBody: 'objself send: #getIV withArguments: #(#receiver)'.	objMessage 		addUnaryMethod: #selector 		withBody: 'objself send: #getIV withArguments: #(#selector)'.			objMessage 		addUnaryMethod: #arguments 		withBody: 'objself send: #getIV withArguments: #(#arguments)'.		objMessage 		addMethod: #setReceiver		args: 'receiver'		withBody:' objself send: #setIV withArguments: (Array with: #receiver with: receiver)'.			objMessage 		addMethod: #setSelector		args: 'selector'		withBody:' objself send: #setIV withArguments: (Array with: #selector with: selector)'.	objMessage 		addMethod: #setArguments		args: 'arguments'		withBody:' objself send: #setIV withArguments: (Array with: #arguments with: arguments)'.							^ objMessage ! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 1/1/2018 20:14'!bootstrap	"self bootstrap"		self initialize.	self manuallyCreateObjClass.	self createObjObject.	self createObjClass.! !!Obj class methodsFor: 'meta data' stamp: 'StephaneDucasse 1/1/2018 20:14'!classInstanceVariables	^ #(#class #name #superclass #iv #keywords #methodDict)! !!Obj class methodsFor: 'bootstrap objClass' stamp: 'StephaneDucasse 1/1/2018 20:14'!createObjClass	"self bootstrap"	| objClass |	objClass := self objClassStructure.	self defineAllocateMethodIn: objClass.	self defineNewMethodIn: objClass.	self defineInitializeMethodIn: objClass.	objClass 		addUnaryMethod: #isMetaclass		withBody: 'objself objIVs includes: #superclass'.		"an object is a class if is class is a metaclass. cool"		objClass 		addUnaryMethod: #isClass		withBody: 'objself objClass send: #isMetaclass withArguments:#()'.	^objClass! !!Obj class methodsFor: 'bootstrap objObject' stamp: 'StephaneDucasse 1/1/2018 20:14'!createObjObject	| objObject |	objObject := self objObjectStructure.	objObject addUnaryMethod: #class withBody: 'objself objClass'.	objObject addUnaryMethod: #isClass withBody: 'false'.	objObject addUnaryMethod: #isMetaclass withBody: 'false'. 	objObject 		addMethod: #error		args: 'arrayOfArguments'		withBody: 'Transcript show: ''error '', arrayOfArguments first.  ''error '', arrayOfArguments first'.	"some meta facilities"	objObject 		addMethod: #getIV		args: 'iv'		withBody: 'objself valueOfInstanceVariable: iv'.	objObject 		addMethod: #setIV		args: 'iv val'		withBody: 			' objself at: (objself offsetFromObjectOfInstanceVariable: iv) put: val'.	objObject 		addMethod: #initialize		args: 'initargs'		withBody: 'objself  initializeUsing: initargs'.	^objObject! !!Obj class methodsFor: 'global class repository management' stamp: 'StephaneDucasse 1/1/2018 20:14'!declareClass: anObjClass 	"To declare an ObjClass in the class repository"	| nameC |	nameC := anObjClass objName.	nameC isNil		ifFalse: [definedObjClasses at: nameC put: anObjClass]		ifTrue: [self error: 'The class does not have a name']! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 1/1/2018 20:14'!defineAllocateMethodIn: class 	"The allocated obj method simply invokes the primitive allocateAnInstance."		class 		addUnaryMethod: #allocate 		withBody: 'objself allocateAnInstance'! !!Obj class methodsFor: 'bootstrap objClass' stamp: 'StephaneDucasse 1/1/2018 20:14'!defineInitializeMethodIn: objClass 	objClass 		addMethod: #initialize		args: 'initArray'		withBody: 			'objself super: #initialize withArguments: {initArray} from: superClassOfClassDefiningTheMethod.			objself objIVs: (objself							computeNewIVFrom: (Obj giveClassNamed: objself objSuperclassId) objIVs							with: objself objIVs).			objself computeAndSetKeywords.			objself objMethodDict: IdentityDictionary new.			Obj declareClass: objself.			objself'! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 1/1/2018 20:14'!defineManualInitializeMethodIn: class 	class 		addMethod: #initialize		args: 'initArray'		withBody: 				'| objsuperclass |			objself initializeUsing: initArray.	"Initialize a class as an object. In the bootstrapped system will be done via super"			objsuperclass := Obj giveClassNamed: objself objSuperclassId ifAbsent: [nil].			objsuperclass isNil				ifFalse: 					[objself						objIVs: (objself computeNewIVFrom: objsuperclass objIVs with: objself objIVs)]				ifTrue: 					[objself objIVs: (objself computeNewIVFrom: #(#class) with: objself objIVs)].			objself				objKeywords: (objself generateKeywords: (objself objIVs copyWithout: #class)).			objself objMethodDict: (IdentityDictionary new: 3).			Obj declareClass: objself.			objself'! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 1/1/2018 20:14'!defineNewMethodIn: class 	class 		addMethod: #new		args: 'initArray'		withBody: 			'(objself send: #allocate withArguments: #()) send: #initialize withArguments: { initArray } '.! !!Obj class methodsFor: 'tricks' stamp: 'StephaneDucasse 1/1/2018 20:14'!doesNotUnderstand: aMessage	"debugging >>>  default shiftDown ifTrue:[ self halt ]."	"Sensor shiftPressed ifTrue:[ self halt ]."		^ definedObjClasses at: aMessage selector! !!Obj class methodsFor: 'global class repository management' stamp: 'StephaneDucasse 1/1/2018 20:14'!giveClassNamed: aSymbol 	"Return the class defined in the class repository with the name aSymbol"	^ self giveClassNamed: aSymbol ifAbsent: [self error: ('The class ' , aSymbol printString , ' is not defined')]! !!Obj class methodsFor: 'global class repository management' stamp: 'StephaneDucasse 1/1/2018 20:14'!giveClassNamed: aSymbol ifAbsent: aBlock	^ definedObjClasses at: aSymbol ifAbsent: aBlock! !!Obj class methodsFor: 'initialize' stamp: 'StephaneDucasse 1/1/2018 20:14'!initialize	"self initialize"	 	definedObjClasses := IdentityDictionary new.	definedObjClasses at: #ObjClass put: nil.	definedObjClasses at: #ObjObject put: nil.	definedObjClasses at: #ObjMessage put: nil.! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 1/1/2018 20:14'!manualObjClassStructure	| class |	class := Obj new: 6.	class objClassId: #ObjClass.	class objName: #ObjClass.	class objIVs: self classInstanceVariables.	class objKeywords: #(#name: #superclass: #iv: #keywords: #methodDict:).	class objSuperclassId: #ObjObject.	class objMethodDict: (IdentityDictionary new: 3).	^ class! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 1/1/2018 20:14'!manuallyCreateObjClass	"self manuallyCreateObjClass"	| class |	class := self manualObjClassStructure.	Obj declareClass: class.	self defineManualInitializeMethodIn: class.	self defineNewMethodIn: class.	self defineAllocateMethodIn: class.	^class! !!Obj class methodsFor: 'bootstrap objClass' stamp: 'StephaneDucasse 1/1/2018 20:14'!objClassStructure	^(Obj giveClassNamed: #ObjClass) send: #new		withArguments: #(#(#name: #ObjClass #iv: #(#name #superclass #iv #keywords #methodDict) #superclass: #ObjObject))! !!Obj class methodsFor: 'bootstrap objMessage' stamp: 'StephaneDucasse 1/1/2018 20:14'!objClassStructureMessage	^ Obj ObjClass 		send: #new		withArguments: #(#(#name: #ObjMessage #iv: #(#receiver #selector #arguments) #superclass: #ObjObject))! !!Obj class methodsFor: 'bootstrap objObject' stamp: 'StephaneDucasse 1/1/2018 20:14'!objObjectStructure	^(Obj giveClassNamed: #ObjClass) 		send: #new		withArguments: #(#(#name: #ObjObject #iv: #(#class)))! !!Obj class methodsFor: 'skeleton metadata' stamp: 'StephaneDucasse 1/1/2018 20:14'!selectorsToSkeletonize	"Skeletonizer new 		selectors: Obj selectorsToSkeletonize;		sourceClassName: #Obj;		targetClassName: #ObjSkeleton;		installClass;		skeletonize		"	^ #(objIVs objIVs: objKeywords objKeywords: objMethodDict objMethodDict: objName objName: objSuperclassId objSuperclassId: objClass objClassId objClassId: allocateAnInstance offsetFromClassOfInstanceVariable: offsetFromObjectOfInstanceVariable: valueOfInstanceVariable: #send:withArguments: #super:withArguments:from: lookup: bodyOfMethod:)! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!addMethod: aSelector args: aString withBody: aStringBlock 	"Define a method with selector <aSelector> , having a string representing the arguments (ie 'aNumber aStream') 	and a string representing the method body in the receiver.	If a method with the same selector already existed, the new definition will erase it.	self is an objClass"	self  objMethodDict at: aSelector put: (self methodWithHeader: aString andBody: aStringBlock).	^self! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!addUnaryMethod: aSelector withBody: aStringBlock 	"Define a unary method with selector <aSelector> and a body <aaStringBlock> in the receiver.	If a method with the same selector already existed, the new definition will erase it.	self is an objClass"	self  addMethod: aSelector args: '' withBody: aStringBlock! !!Obj methodsFor: 'instance allocation' stamp: 'StephaneDucasse 1/1/2018 20:14'!allocateAnInstance	"Returns a newly created instance of self, an ObjClass. In this implementation the identifier of the object class is the name of the class. "	^ self! !!Obj methodsFor: 'message passing' stamp: 'StephaneDucasse 1/1/2018 20:14'!basicSend: selector withArguments: arguments from: aClass	"Execute the method found starting from aClass and whose name is selector."	"The core of the sending a message, reused for both a normal send or a super one."		| methodOrNil |	methodOrNil := aClass lookup: selector.	^ methodOrNil 		ifNotNil: [ methodOrNil valueWithArguments: (Array with: self) , arguments ] 		ifNil: [ self sendError: selector withArgs: arguments ] ! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!blockArgsFrom: aCol	"self basicNew blockArgsFrom: ' abc def ghi '"			| col st |	col := aCol findTokens: Character space.	col := col copyWithout: ''.	st := ''.	col do: [ :each | st := st , ':', each ] separatedBy: [st := st, ' '].	^ st! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!bodyOfMethod: aSelector	"Return the method associated with the selector <aSelector> in the receiver.	Return nil if the selector is not defined.  self is an objClass"	^ self! !!Obj methodsFor: 'debugging' stamp: 'StephaneDucasse 1/1/2018 20:14'!classDebug	"(self giveClassNamed: #ObjClass) classDebug"	"(self giveClassNamed: #ObjSet) classDebug"	ObjClassInspector basicInspect: self! !!Obj methodsFor: 'keyword management' stamp: 'StephaneDucasse 1/1/2018 20:14'!computeAndSetKeywords	"Compute the keywords of a given class.  As the class of an object should not be changed.	 the keywords should note contain the keyword class. self is anObjClass"	self objKeywords: (self generateKeywords: (self objIVs copyWithout: #class))! !!Obj methodsFor: 'iv inheritance' stamp: 'StephaneDucasse 1/1/2018 20:14'!computeNewIVFrom: superIVOrdCol with: localIVOrdCol	"Returns an ordered collection that is the union without duplicate of ivOfSuper and ivOrderedCollection.	Important the order of the instance variable is conserved"	| ivs |	^superIVOrdCol isNil 		ifTrue: [localIVOrdCol]		ifFalse: 			[ivs := superIVOrdCol asOrderedCollection copy.			localIVOrdCol do: [:e | (ivs includes: e) ifFalse: [ivs add: e]].			ivs]! !!Obj methodsFor: 'iv inheritance' stamp: 'StephaneDucasse 1/1/2018 20:14'!computeNewIVFromClass: anObjClass with: ivOrderedCollection 	"Obj computeNewIVFromClass: #(#C #C #O #(a b c d)) with: #(a z b t) asOrderedCollection"	| ivs |	^anObjClass isNil		ifTrue: [ivOrderedCollection]		ifFalse: 			[ivs := anObjClass objIVs asOrderedCollection copy.			ivOrderedCollection do: [:e | (ivs includes: e) ifFalse: [ivs add: e]].			ivs]! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!doesUnderstand: aSelector 	"Tell if the receiver has a method having <aSelector> as selector. self is anObjClass"	^self objMethodDict keys includes: aSelector! !!Obj methodsFor: 'keyword management' stamp: 'StephaneDucasse 1/1/2018 20:14'!generateKeywords: anArray 	"Returns an array containing the keywords made from the collection of Symbol passed as argument"	"self new generateKeywords: #(titi toto lulu) "	^anArray collect: [:e | (e , ':') asSymbol]! !!Obj methodsFor: 'instance initialization' stamp: 'StephaneDucasse 1/1/2018 20:14'!initializeUsing: anAlternatedArray 	"Returns the receiver an ObjObject initialized according to the directives given by anAlternateArray"	| ivValues |	ivValues := self 						returnValuesFrom: anAlternatedArray						followingSchema: self objClass objKeywords.	1 to:  ivValues size			do: [:i | self at: i + 1 put: (ivValues at: i)].	^ self ! !!Obj methodsFor: 'keyword management' stamp: 'StephaneDucasse 1/1/2018 20:14'!keywordValue: aSymbol getFrom: anArray ifAbsent: aDefaultValue 	"precondition: ((length anArray) mod 2) = 0 	returns the value associated with the keyword represented by aSymbol 	in the initarg list represented by anArray."	"self new keywordValue: #titi getFrom: #(toto 12 titi 23) ifAbsent: 2"	"self new keywordValue: #titi getFrom: #(toto 23) ifAbsent: 2"	| i |	i := anArray indexOf: aSymbol ifAbsent: nil.	^i isNil 		ifTrue: [aDefaultValue] 		ifFalse: [anArray at: i + 1]! !!Obj methodsFor: 'method lookup' stamp: 'StephaneDucasse 1/1/2018 20:14'!lookup: selector	"look for the method named <selector> starting in the receiver. 	The lookup is done for a message sent to <anObjObject>. self is an objClass"	^ self! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!methodWithHeader: col andBody: aString 	| block string resBlock |	string := self stringOfBlockBodyFromHeader: col andBody: aString.	block := Compiler evaluate: string.	"bind superclass to the superclass of the class defining the method"	resBlock := block value: (Obj giveClassNamed: self objSuperclassId ifAbsent: [666]).	^resBlock! !!Obj methodsFor: 'iv management' stamp: 'StephaneDucasse 1/1/2018 20:14'!numberOfIVs	"Returns the number of instance variables of the class an ObjClass"	^self objIVs size! !!Obj methodsFor: 'object structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objClass	"Receiver should be: anObjObject. Returns the class of the receiver (which is an ObjObject) and not its internal identification. Differs from classId  which is a primitive to access the structure representing a class"	^ self! !!Obj methodsFor: 'object structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objClassId	"Receiver should be: anObjObject. Returns the identifier that identifies the class of the receiver (an objObject). In this implementation we chose to use the class name as identifier"	^ self! !!Obj methodsFor: 'object structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objClassId: anObjClassId	"Receiver should be: anObjObject. Set the identifier that identifies the class of the receiver (anObjObject)."	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objIVs	"Receiver should be: anObjClass. Returns the list of instance variables"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objIVs: anOrderedCollection	"Receiver should be: anObjClass. Set the list of instance variable names of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objKeywords	"Receiver should be: anObjClass. Returns the keyword list of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objKeywords: anOrderedCollection	"Receiver should be: anObjClass. Sets the list of keywords of the receiver (anObjClass). Note that this method is just an accessor and does not compute the actual list of keywords"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objMethodDict	"Receiver should be: anObjClass. Returns the method dictionary of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objMethodDict: aDictionary	"Receiver should be: anObjClass. Sets the method dictionary of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objName	"Receiver should be: anObjClass. Returns the name of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objName: aName	"Receiver should be: anObjClass. Set the name of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objSuperclass	"Receiver should be: anObjClass. Returns the superclass of the receiver (which is an objClass) and not its internal identification. Differs from superclassId which is a primitive to access the structure representing a class"	^Obj giveClassNamed: self objSuperclassId! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objSuperclassId	"Receiver should be: anObjClass. Returns the superclass id of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objSuperclassId: anObjClassId	"Receiver should be: anObjClass. Set the superclass id of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'object structure offset' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetForClass	^1! !!Obj methodsFor: 'class structure offset' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetForIVs	^4! !!Obj methodsFor: 'class structure offset' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetForKeywords	^5! !!Obj methodsFor: 'class structure offset' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetForMethodDict	^6! !!Obj methodsFor: 'class structure offset' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetForName	^2! !!Obj methodsFor: 'class structure offset' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetForSuperclass	^3! !!Obj methodsFor: 'iv management' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetFromClassOfInstanceVariable: aSymbol	"Returns the index of the instance variable named aSymbol for an class anObjClass.	Returns 0 if the aSymbol is not present in the instance variable lists of anObjClass"	^ self! !!Obj methodsFor: 'keyword management' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetFromObjectOfInstanceVariable: aSymbol	"Returns the offset of the instance variable named aSymbol in the object anObjObject.	If aSymbol is not an instance variable is not an instance variable of the object raise an error"	^ self! !!Obj methodsFor: 'printing' stamp: 'StephaneDucasse 1/1/2018 20:14'!printOn: aStream	aStream nextPutAll: 'an Obj object: '.		super printOn: aStream! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!removeMethod: aSelector	"Remove the method with aSelector <aSymbol> in the receiver. 	self is an objClass"	self objMethodDict removeKey: aSelector ifAbsent: [].	^self! !!Obj methodsFor: 'keyword management' stamp: 'StephaneDucasse 1/1/2018 20:14'!returnValuesFrom: anInitargArray followingSchema: anArrayOfKeywords 	"Return the values associated with the keys. The extracted values are taken from <anInitargArray> 	and the return values are extracted according to the schema defined by the collection of keys <anArrayOfKeywords>"	"self new returnValuesFrom: #(lulu 22  titi 35)  followingSchema: #(titi toto lulu titi)  #(35 nil 22 35)"	^anArrayOfKeywords collect: 			[:e | 			self keywordValue: e				getFrom: anInitargArray 				ifAbsent: nil]! !!Obj methodsFor: 'message passing' stamp: 'StephaneDucasse 1/1/2018 20:14'!send: selector withArguments: arguments	"send the message whose selector is <selector> to the receiver. The arguments of the messages are an array <arguments>. The method is lookep up in the class of the receiver. self is an objObject or a objClass."	^ self! !!Obj methodsFor: 'message passing' stamp: 'StephaneDucasse 1/1/2018 20:14'!sendError: selector withArgs: arguments	"send error wrapping arguments into an array with the selector as first argument. Instead of an array we should create a message object."		^ self send: #error withArguments:  {(arguments copyWithFirst: selector)}	! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!stringOfBlockBodyFromHeader: col andBody: aString 	^ '[ :superClassOfClassDefiningTheMethod |		[ :objself ' , (self blockArgsFrom: col) , ' |					 ' , aString , '] ]'! !!Obj methodsFor: 'message passing' stamp: 'StephaneDucasse 1/1/2018 20:14'!super: selector withArguments: arguments from: aSuperclass	"Invoke an oveeriden method named <selector> with an array of arguments <arguments>.  self is an objClass. aSuperclass should be the superclass of the class containing the method using super"	^ self! !!Obj methodsFor: 'iv management' stamp: 'StephaneDucasse 1/1/2018 20:14'!valueOfInstanceVariable: aSymbol	^ self! !!StrictlyOrderedEyeElement methodsFor: 'accessing' stamp: 'StephaneDucasse 11/16/2014 23:08'!orderedStructure		^ orderedStructure! !!StrictlyOrderedEyeElement methodsFor: 'accessing' stamp: 'StephaneDucasse 11/16/2014 23:08'!orderedStructure: anObject		orderedStructure := anObject! !!StrictlyOrderedEyeElement methodsFor: 'accessing' stamp: 'StephaneDucasse 11/16/2014 23:08'!value	^ self host basicAt: (self orderedStructure indexOf: index)! !!ObjClassInspector methodsFor: 'list' stamp: 'StephaneDucasse 11/16/2014 23:10'!addVariableFields: elements		| classStructure |	classStructure := Obj classInstanceVariables.	classStructure do: [ :key |		elements add: (StrictlyOrderedEyeElement new 								orderedStructure: classStructure;								host: self object;								index: key; 								yourself)]! !"ObjVSkeleton"!----QUIT/NOSAVE----2024-12-02T14:50:30.495882+01:00 Pharo 8.0 - 64bit.image priorSource: 3321!!RawObjTest commentStamp: 'StephaneDucasse 11/17/2014 11:09' prior: 0!These tests are based on a setup that does not rely on structure for the accessors.!!ObjClassInspector commentStamp: 'StephaneDucasse 11/16/2014 23:11' prior: 0!I'm a simple inspector that can inspect fixed structured Obj class."creating class by hand"| coloredPointClass |coloredPointClass := Obj new: 6.coloredPointClass at: coloredPointClass offsetForName put: #ObjColoredPoint.coloredPointClass at: coloredPointClass offsetForClass put: #ObjClass.coloredPointClass at: coloredPointClass offsetForIVs put: #( #class #x #y #color).coloredPointClass at: coloredPointClass offsetForSuperclass put: #ObjPoint.coloredPointClass at: coloredPointClass offsetForMethodDict	put: (IdentityDictionary new).coloredPointClass.ObjClassInspector basicInspect: coloredPointClass.!!ObjExampleTest class methodsFor: 'first user-defined metaclasses'!setMetaclassDefinition	"self setMetaclassDefinition"	| setClass |	setClass := Obj ObjClass				send: #new				withArguments: #(#(#name: #ObjSet #iv: #(#myInstances) #superclass: #ObjClass)).	"initialize on a metaclass"	setClass 		addMethod: #initialize		args: 'initArray'		withBody: 			'			objself binarySuper: #initialize with: initArray from: superClassOfClassDefiningTheMethod.			objself send: #setIV				withArguments: (Array with: #myInstances with: OrderedCollection new).			objself'.	setClass addUnaryMethod: #instances		withBody: 'objself binarySend: #getIV with: #myInstances'.	setClass addMethod: #new		args: 'initArray'		withBody: 			'| newInst others |			newInst := objself super: #new withArguments: (Array with: initArray) from: superClassOfClassDefiningTheMethod.			others := objself unarySend: #instances.			others := others add: newInst;						yourself.			objself send: #setIV withArguments: (Array with: #myInstances with: others).			newInst'! !!ObjExampleTest class methodsFor: 'first user-defined metaclasses' stamp: 'StephaneDucasse 11/26/2014 22:04'!setMetaclassExample	"self setMetaclassExample"	| memoPointClass |	self setMetaclassDefinition.	memoPointClass := Obj ObjSet 						send: #new						withArguments: #(#(#name: #ObjMemoPoint  #iv: #() #superclass: #ObjPoint)).	memoPointClass send: #new withArguments: #(#(#x: 24 #y: 6)).	memoPointClass send: #new withArguments: #(#(#x: 15 #y: 10)).	^memoPointClass send: #instances withArguments: #().! !!ObjExampleTest methodsFor: 'setup'!abstractMetaclassDefinition 	(Obj giveClassNamed: #ObjClass)					 		send: #new							withArguments: #(#(#name: #ObjAbstractClass #iv: #() #superclass: #ObjClass)).	Obj ObjAbstractClass 		addMethod: #new		args: 'initArray'		withBody: 			' objself error: '' the class '' , objself objName asString , '' is abstract'''! !!ObjExampleTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:52'!defineObjAbstractPoint	(Obj ObjAbstractClass)		send: #new		withArguments: #(#(#name: #ObjAbstractPoint #iv: #() #superclass: #ObjObject)).	Obj ObjAbstractPoint		addUnaryMethod: #givex		withBody: 'objself  valueOfInstanceVariable: #x '.	Obj ObjAbstractPoint 		addUnaryMethod: #display		withBody: 			'Transcript cr;				show: ''aPoint with x = ''.			Transcript show: (objself send: #givex withArguments: #()) printString;				cr'.! !!ObjExampleTest methodsFor: 'setup'!defineObjPoint	Obj ObjClass send: #new		withArguments: #(#(#name: #ObjPoint #iv: #(#x #y) #superclass: #ObjAbstractPoint)).! !!ObjExampleTest methodsFor: 'setup'!setUp	Obj bootstrap.	self abstractMetaclassDefinition.	self defineObjAbstractPoint.	self defineObjPoint! !!ObjExampleTest methodsFor: 'test abstract'!testAbstractMetaclassExample	self should: [Obj ObjAbstractClass send: #new withArguments: #(#(#x: 24 #y: 6))] raise: Error.! !!ObjExampleTest methodsFor: 'test abstract'!testAbstractMetaclassExampleWithConcreteSubclass	self shouldnt: [Obj ObjPoint send: #new withArguments: #(#(#x: 24 #y: 6))]		raise: Error! !!ObjExampleTest methodsFor: 'test abstract' stamp: 'StephaneDucasse 11/27/2014 20:48'!testColoredPoint	| coloredPointClass aColoredPoint |	coloredPointClass := (Obj ObjClass)						 	send: #new 							withArguments: #((#name: #ObjColoredPoint 							           		   #iv: #(#color) 							            	  #superclass: #ObjPoint)).	aColoredPoint := coloredPointClass send: #new withArguments: #((#x: 24 #y: 6 #color: #blue)).		"first messages sent"	self assert: (aColoredPoint send: #getIV withArguments: #(#x)) = 24.	aColoredPoint send: #setIV withArguments: #(#x 25).	self assert: (aColoredPoint send: #getIV withArguments: #(#x)) = 25.	self assert: (aColoredPoint send: #getIV withArguments: #(#color)) = #blue.		"adding some methods"	coloredPointClass 		addUnaryMethod: #giveColor		withBody: 'objself send: #getIV withArguments: #(#color)'.	coloredPointClass 		addMethod: #setColor		args: 'col'		withBody:' objself send: #setIV withArguments: (Array with: #color with: col)'.	coloredPointClass addUnaryMethod: #display		withBody:  			'objself super: #display withArguments: #() from: superClassOfClassDefiningTheMethod.			Transcript cr;				show: '' with Color = ''.			Transcript show: (objself send: #giveColor withArguments: #()) printString;				cr'.	self assert: (aColoredPoint send: #giveColor withArguments: #()) = #blue.		self assert: (aColoredPoint send: #givex withArguments: #()) = 25.		aColoredPoint send: #display withArguments: #().! !!ObjMessageTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/26/2014 15:33'!setUp	Obj bootstrap.	Obj objClassStructureMessage.! !!ObjMessageTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/26/2014 22:05'!testMessageClassMethods	"self debug: #testMessageClassMethods"		| msg |	Obj addMessagesForErrorHandling.	msg := Obj ObjMessage 				send: #new 				withArguments: #(#(#receiver: 24 #selector: #factorial)).		self assert: (msg send: #receiver2 withArguments: #()) equals: 24.	self assert: (msg send: #receiver withArguments: #()) equals: 24.	self assert: (msg send: #selector withArguments: #()) equals: #factorial.		msg := Obj ObjMessage 		send: #new 		withArguments: #(#(#receiver: 24 #selector: #+ arguments: #(25))).	self assert: (msg send: #arguments withArguments: #())  equals: #(25).! !!ObjMessageTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/20/2014 14:52'!testMessageClassMethodsDefined	"self debug: #testMessageClassMethodsDefined"		| msg |	Obj addMessagesForErrorHandling.	self deny: Obj ObjMessage objMethodDict size isZero! !!ObjMessageTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/20/2014 10:16'!testMessageClassStructureDeclared	Obj objClassStructureMessage.	self assert: Obj ObjMessage objName = #ObjMessage.	self assert: Obj ObjMessage objClass objName= #ObjClass.	self assert: Obj ObjMessage objIVs asArray = #(#class #receiver #selector #arguments).	self assert: Obj ObjMessage objSuperclass = Obj ObjObject	! !!ObjMessageTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/20/2014 15:05'!testUsingPrimitivesMessageClassMethods	| msg |	msg := Obj ObjMessage 		send: #new 		withArguments: #(#(#receiver: 24 #selector: #factorial)).		self assert: (msg at: 1) equals: #ObjMessage.	self assert: (msg at: 2) equals: 24.	self assert: (msg at: 3) equals: #factorial.		msg := Obj ObjMessage 		send: #new 		withArguments: #(#(#receiver: 24 #selector: #+ arguments: #(25))).	self assert: (msg at: 4)  equals: #(25).! !!ObjTest methodsFor: 'setup'!assembleClassClass	classClass := Obj new: 6.	classClass at: classClass offsetForName put: #ObjClass.	classClass at: classClass offsetForClass put: #ObjClass.	classClass at: classClass offsetForIVs		put: #(#class #name #superclass #iv #keywords #methodDict).	classClass at: classClass offsetForKeywords		put: #(#name: #superclass: #iv: #keywords: #methodDict:).	classClass at: classClass offsetForSuperclass put: #ObjObject.	classClass at: classClass offsetForMethodDict		put: (IdentityDictionary new).	Obj declareClass: classClass! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 10/22/2009 16:24'!assembleColoredInstance	aColoredPoint := Obj new: 4.	aColoredPoint at: 1 put: #ObjColoredPoint.	aColoredPoint at: 2 put: 10.	aColoredPoint at: 3 put: 15.	aColoredPoint at: 4 put: #blue! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:36'!assembleColoredPointClass	coloredPointClass := Obj new: 6.	coloredPointClass at: pointClass offsetForName put: #ObjColoredPoint.	coloredPointClass at: pointClass offsetForClass put: #ObjClass.		"Here the initialize of metaclass is not available so we perform the instance variable lookup by hand."	coloredPointClass at: pointClass offsetForIVs put: #( #class #x #y #color).	coloredPointClass at: pointClass offsetForSuperclass put: #ObjPoint.	coloredPointClass at: pointClass offsetForMethodDict		put: (IdentityDictionary new).	Obj declareClass: coloredPointClass.	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'I''am a colored point';				cr]] value: pointClass).	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod)				]] value: pointClass).	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #bar		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #bar withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #bar withArguments:#() from: superClassOfClassDefiningTheMethod)]			] value: pointClass).! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 2/15/2011 16:10'!assembleIncrementalColoredInstance		aIncrementalColoredPoint := Obj new: 4.	aIncrementalColoredPoint at: 1 put: #ObjIncrementalColoredPoint.	aIncrementalColoredPoint at: 2 put: 10.	aIncrementalColoredPoint at: 3 put: 15.	aIncrementalColoredPoint at: 4 put: #blue! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:37'!assembleIncrementalColoredPointClass	incrementalColoredPointClass := Obj new: 6.	incrementalColoredPointClass at: pointClass offsetForName put: #ObjIncrementalColoredPoint.	incrementalColoredPointClass at: pointClass offsetForClass put: #ObjClass.		"Some tests will invoke by hand computeIV... so we do not have to hardcode the sequence."	incrementalColoredPointClass at: pointClass offsetForIVs put: #( #color).	incrementalColoredPointClass at: pointClass offsetForSuperclass put: #ObjPoint.	incrementalColoredPointClass at: pointClass offsetForMethodDict		put: (IdentityDictionary new).	Obj declareClass: incrementalColoredPointClass.	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'I''am a colored point';				cr]] value: pointClass).	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod)				]] value: pointClass).	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #bar		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #bar withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #bar withArguments: #() from: superClassOfClassDefiningTheMethod)]			] value: pointClass).! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/26/2014 16:01'!assembleObjectClass	objectClass := Obj new: 6.	objectClass at: objectClass offsetForName put: #ObjObject.	objectClass at: objectClass offsetForClass put: #ObjClass.	objectClass at: objectClass offsetForIVs put: #(#class).	objectClass at: objectClass offsetForKeywords put: #().	objectClass at: objectClass offsetForSuperclass put: nil.	objectClass at: objectClass offsetForMethodDict put: (IdentityDictionary new).	Obj declareClass: objectClass.	"here I simulate by hand the way superclass is captured for super lookup, I value the block with nil for now to represent	the superclass of ObjObject"	(objectClass at: objectClass offsetForMethodDict) at: #print		put: 			([:superClassOfClassDefiningTheMethod |				[:objself | 			Transcript show: 'I''am an Object';				cr]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #error		put: 			([:superClassOfClassDefiningTheMethod |				[:object :arrayOfArguments | 			Transcript show: 'Error: selector ' , arrayOfArguments first printString , ' not understood';				cr.				Error signal]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #getIV		put: ([:superClassOfClassDefiningTheMethod | [:object :iv | object valueOfInstanceVariable: iv]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #setIV		put: 			([:superClassOfClassDefiningTheMethod | [:object :iv :val | 			object at: (object offsetFromObjectOfInstanceVariable: iv) put: val]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #bar		put: 			([:superClassOfClassDefiningTheMethod | [:objself | 					5]] value: nil).! !!ObjTest methodsFor: 'setup'!assemblePointClass	| cl |	cl := Obj giveClassNamed: #ObjClass.	pointClass := Obj new: (cl at: cl offsetForIVs) size.	pointClass at: pointClass offsetForName put: #ObjPoint.	pointClass at: pointClass offsetForClass put: #ObjClass.	pointClass at: pointClass offsetForIVs put: #(#class #x #y).	pointClass at: pointClass offsetForKeywords put: #(#x: #y:).	pointClass at: pointClass offsetForSuperclass put: #ObjObject.	pointClass at: pointClass offsetForMethodDict		put: (IdentityDictionary new).	Obj declareClass: pointClass.	(pointClass at: pointClass offsetForMethodDict) at: #x		put: ([ :superClassOfClassDefiningTheMethod | [:objself | objself valueOfInstanceVariable: #x]] value: objectClass).	(pointClass at: pointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | [:objself | 			Transcript show: 'I''am a Point';				cr]] value: objectClass).	(pointClass at: pointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'ObjPoint>>foo';cr.				5				]] value: objectClass)! !!ObjTest methodsFor: 'setup'!assemblePointInstance	aPoint := Obj new: 3.	aPoint at: 1 put: #ObjPoint.	aPoint at: 2 put: 10.	aPoint at: 3 put: 15! !!ObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 2/15/2011 16:15'!setUp	"self new setUp"	Obj initialize.	self assembleClassClass.	self assemblePointClass.	self assembleObjectClass.	self assembleColoredPointClass.	self assemblePointInstance.	self assembleColoredInstance.	self assembleIncrementalColoredInstance.	self assembleIncrementalColoredPointClass! !!ObjTest methodsFor: 'step5-tests-allocate' stamp: 'StephaneDucasse 11/21/2015 15:44'!testAllocate  "(self  selector: #testAllocate) run"  | newInstance |  newInstance := pointClass allocateAnInstance.  self assert: (newInstance at: 1) = #ObjPoint.  self assert: (newInstance size) = 3.  self assert: (newInstance at: 2) isNil.  self assert: (newInstance at: 3) isNil.  self assert: (newInstance objClass = pointClass)! !!ObjTest methodsFor: 'utilities tests'!testBlockArgsFrom	self assert: (Obj new blockArgsFrom: ' abc def ghi ')  = ':abc :def :ghi'.	self assert: (Obj new blockArgsFrom: 'abc def ghi')  = ':abc :def :ghi'.	self assert: (Obj new blockArgsFrom: '')  = ''.! !!ObjTest methodsFor: 'utilities tests' stamp: 'NicoPAez 10/21/2010 10:22'!testBlockBodyFromHeaderAndBody	"a method with one argument: val"	self assert: (Obj new stringOfBlockBodyFromHeader: 'val' andBody: 'objself send: #setIV 										 withArguments: (Array with: #x with: val).')										= '[ :superClassOfClassDefiningTheMethod |		[ :objself :val |					 objself send: #setIV 										 withArguments: (Array with: #x with: val).] ]'.	"a method without arg"	self assert: (Obj new stringOfBlockBodyFromHeader: '' andBody: 'objself unarySend: #getx.') 	='[ :superClassOfClassDefiningTheMethod |		[ :objself  |					 objself unarySend: #getx.] ]'	! !!ObjTest methodsFor: 'step3-tests-class access'!testClassAccess	"(self  selector: #testClassAccess) run"		self assert: (aPoint objClass = pointClass)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:52'!testErrorRaisedSendWhenErrorInLookup	"(self  selector: #testErrorRaisedSendWhenErrorInLookup) run"		self should: [  pointClass sendError: #zork withArgs: { aPoint } ] raise: Error.	"Open a Transcript to see the message trace"! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/27/2014 21:15'!testErrorRedefinition	"(self  run: #testErrorRedefinition)"		self should: [aPoint send: #zork withArguments: #()] raise: Error.	(pointClass at: pointClass offsetForMethodDict) at: #error		put: ([ :superClassOfClassDefiningTheMethod | [:objself :selector | 33]] value: objectClass).		self assert: (aPoint send: #zork withArguments: #()) = 33.	(pointClass at: pointClass offsetForMethodDict) at: #error		put: ([ :superClassOfClassDefiningTheMethod | [:objself :selector | 33]] value: objectClass).	self assert: (aPoint send: #zork withArguments: #(44)) = 33.! !!ObjTest methodsFor: 'step4-tests-iv management'!testIVOffset	"(self  selector: #testIVOffset) run"	self assert: ((pointClass offsetFromClassOfInstanceVariable: #x ) = 2).	self assert: ((pointClass offsetFromClassOfInstanceVariable: #lulu ) = 0)! !!ObjTest methodsFor: 'step4-tests-iv management'!testIVOffsetAndValue	"(self  selector: #testIVOffsetAndValue) run"	self assert: ((aPoint offsetFromObjectOfInstanceVariable: #x ) = 2).	self assert: ((aPoint valueOfInstanceVariable: #x ) = 10)! !!ObjTest methodsFor: 'step7-tests-initialize' stamp: 'StephaneDucasse 11/21/2015 16:16'!testInitialize	"(self  selector: #testInitialize) run"	| newInstance  |	newInstance := pointClass allocateAnInstance.	newInstance initializeUsing: #(#y: 2 #z: 3 #t: 55 #x: 1).	self assert: (newInstance at: 1) equals: #ObjPoint.	self assert: (newInstance at: 2) equals: 1.	self assert: (newInstance at: 3) equals: 2.! !!ObjTest methodsFor: 'step8-tests-instance variable inheritance'!testInstanceVariableInheritance	"(self  selector: #testInstanceVariableInheritance) run"	"a better choice would be to throw an exception if there are duplicates"	self assert: 			((Obj new computeNewIVFrom: #(#a #b #c #d) asOrderedCollection				with: #(#a #z #b #t) asOrderedCollection)					= #(#a #b #c #d #z #t) asOrderedCollection).	self assert: 			((Obj new computeNewIVFrom: #() asOrderedCollection				with: #(#a #z #b #t) asOrderedCollection)					= #(#a #z #b #t) asOrderedCollection)! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables' stamp: 'StephaneDucasse 2/15/2011 16:12'!testInstanceVariableInheritanceFromAClass	"(self  selector: #testInstanceVariableInheritanceFromAClass) run"		aIncrementalColoredPoint objClass objIVs: (aIncrementalColoredPoint computeNewIVFrom: aPoint objClass objIVs  with: aIncrementalColoredPoint objClass objIVs).		self assert: ((pointClass offsetFromClassOfInstanceVariable: #x ) = 2).	self assert: ((incrementalColoredPointClass offsetFromClassOfInstanceVariable: #x ) = 2).	! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables' stamp: 'StephaneDucasse 2/15/2011 16:14'!testInstanceVariableInheritanceFromAObject	"(self  selector: #testInstanceVariableInheritanceFromAObject) run"		aIncrementalColoredPoint objClass objIVs: (aIncrementalColoredPoint computeNewIVFrom: aPoint objClass objIVs  with: aIncrementalColoredPoint objClass objIVs).		self assert: ((aPoint offsetFromObjectOfInstanceVariable: #x ) = 2).	self assert: ((aIncrementalColoredPoint offsetFromObjectOfInstanceVariable: #x ) = 2).			! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables' stamp: 'JB 10/9/2009 16:52'!testInstanceVariableInheritanceNotFind	"(self  selector: #testInstanceVariableInheritanceNotFind) run"		self should: [aPoint offsetFromObjectOfInstanceVariable: #zork ] raise: Error.			! !!ObjTest methodsFor: 'tests-StaticInheritanceOfInstanceVariables' stamp: 'JB 10/13/2009 16:23'!testInstanceVariableInheritanceNumberOfInstanceVar	"(self  selector: #testInstanceVariableInheritanceNumberOfInstanceVar) run"		self assert: ((pointClass numberOfIVs ) = 3).	self assert: ((coloredPointClass numberOfIVs ) = 4).	! !!ObjTest methodsFor: 'step6-tests-keywords'!testKeywords	"(self  selector: #testKeywords) run"	| dummyObject |	dummyObject := Obj new.	self assert: 			((dummyObject generateKeywords: #(#titi #toto #lulu))				= #(#titi: #toto: #lulu:)).	self assert: 			((dummyObject keywordValue: #x				getFrom: #(#toto 33 #x 23)				ifAbsent: 2) = 23).	self assert: 			((dummyObject keywordValue: #x				getFrom: #(#toto 23)				ifAbsent: 2) = 2).	self assert: 			((dummyObject returnValuesFrom: #(#x 22 #y 35) followingSchema: #(#y #yy #x #y))				= #(35 nil 22 35))! !!ObjTest methodsFor: 'tests'!testMethodDefinition	"(self  selector: #testMethodManagment) run"	self assert: (pointClass doesUnderstand: #x).	self assert: (pointClass doesUnderstand: #xx) not.	"define a unary method xx returning the receiver."	pointClass 		addMethod: #xx		args: ''		withBody: 'objself'.	self assert: (pointClass doesUnderstand: #xx).	self assert: (((pointClass bodyOfMethod: #xx) value: 22) = 22).	"define a unary method returning the slot x of the receiver"	pointClass 		addMethod: #getgetx		args: ''		withBody: 'objself valueOfInstanceVariable: #x'.	self assert: (pointClass doesUnderstand: #getgetx).	self assert: (((pointClass bodyOfMethod: #getgetx) value: aPoint) = 10).! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 12/5/2014 17:37'!testMethodLookup	"(self  selector: #testMethodLookup) run"		self assert: ((pointClass lookup: #x) isKindOf: BlockClosure)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:37'!testMethodLookupFindSimpleMethod	"(self  selector: #testMethodLookupFindSimpleMethod) run"	self assert: ((pointClass lookup: #x)  isKindOf: BlockClosure)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:37'!testMethodLookupFindSuperMethod	"(self  selector: #testMethodLookupFindSuperMethod) run"		self assert: ((coloredPointClass lookup: #x) isKindOf: BlockClosure)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:38'!testMethodLookupStop	"(self  selector: #testMethodLookupStop) run"		| foundMethod|	foundMethod := (pointClass lookup: #zork).	self assert: foundMethod isNil. 	"The method zork is NOT implement on pointClass, so nil is returned."	self should: [ pointClass sendError: #error withArgs: {aPoint}] raise: Error.		foundMethod := (pointClass lookup: #error).	self assert: (foundMethod isKindOf: BlockClosure).	self assert: ('*Error*' match: foundMethod printString).		"the message error defined on ObjObject requires two arguments: an object and a selector and it raises 	an error when executed. Open a Transcript to see the message trace"	self should:  [((pointClass lookup: #zork) value: 'r' value: #e)] raise: Error .! !!ObjTest methodsFor: 'tests' stamp: 'NicoPAez 10/21/2010 10:25'!testMethodManagement	"(self  selector: #testMethodManagment) run"	self assert: (pointClass doesUnderstand: #x).	self assert: (pointClass doesUnderstand: #xx) not.		pointClass 		addMethod: #xx		args: ''		withBody: 'objself valueOfInstanceVariable: #x '.	self assert: (((pointClass bodyOfMethod: #xx) value: aPoint) = 10).	self assert: (pointClass doesUnderstand: #xx).	pointClass removeMethod: #xx.	self assert: (pointClass doesUnderstand: #xx) not.	self assert: (((pointClass bodyOfMethod: #x) value: aPoint) = 10)! !!ObjTest methodsFor: 'tests-MethodsManagement' stamp: 'JB 10/9/2009 16:51'!testMethodManagmentAddRemoveMethods	"(self  selector: #testMethodManagmentAddRemoveMethods) run"	pointClass 		addMethod: #xx		args: ''		withBody: 'objself valueOfInstanceVariable: #x '.	self assert: (((pointClass bodyOfMethod: #xx) value: aPoint) = 10).	self assert: (pointClass doesUnderstand: #xx).	pointClass removeMethod: #xx.	self assert: (pointClass doesUnderstand: #xx) not.	self assert: (((pointClass bodyOfMethod: #x) value: aPoint) = 10)! !!ObjTest methodsFor: 'tests-MethodsManagement' stamp: 'JB 10/9/2009 16:51'!testMethodManagmentBodyOfMethod	"(self  selector: #testMethodManagmentBodyOfMethod) run"		self assert: (((pointClass bodyOfMethod: #x) value: aPoint) = 10)! !!ObjTest methodsFor: 'tests-MethodsManagement' stamp: 'JB 10/9/2009 16:52'!testMethodManagmentNotUnderstandBadMethod	"(self  selector: #testMethodManagmentNotUnderstandBadMethod) run"	self assert: (pointClass doesUnderstand: #xx) not.	! !!ObjTest methodsFor: 'tests-MethodsManagement' stamp: 'JB 10/9/2009 16:52'!testMethodManagmentUnderstandGoodMethod	"(self  selector: #testMethodManagmentUnderstandGoodMethod) run"	self assert: (pointClass doesUnderstand: #x).! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/26/2014 22:05'!testMethodNotFoundRaiseError	"(self  run: #testMethodNotFoundRaiseError)"	self should: [aPoint send: #zork withArguments: #()] raise: Error.! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/27/2014 12:18'!testMethodSelfSend	"(self  selector: #testMethodSelfSend) run"	"method found in the class PointClass"	self assert: ((aPoint send: #x withArguments: #()) = 10).	"method found in ObjClass"	self assert: ((aPoint send: #getIV withArguments: #(#x)) = 10).	"method found in ObjClass"	aPoint send: #setIV withArguments: #(y 22).	self assert: ((aPoint send: #getIV withArguments: #(#y)) = 22)! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 11/26/2014 22:22'!testMethodSelfSendUnarySend	"(self  selector: #testMethodSelfSendUnarySend) run"	"method found in the class PointClass"	self assert: ((aPoint send: #x withArguments: #()) = 10).	"method found in the class PointClass"	self assert: ((aColoredPoint send: #x withArguments:#()) = 10).! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/26/2014 22:22'!testMethodSuperCall	"(self  selector: #testMethodSuperCall) run"	"foo in point return 5"	self assert: ((aPoint send: #foo withArguments: #()) = 5).	"foo in colored point is doing super foo + super foo"	self assert: ((aColoredPoint send: #foo withArguments: #()) = 10).! !!ObjTest methodsFor: 'tests' stamp: 'StephaneDucasse 11/26/2014 22:23'!testMethodSuperCallOverBigHierarchy	"(self  selector: #testMethodSuperCallOverBigHierarchy) run"	"bar is defined in Object and not on Point"	self assert: (aPoint send: #bar withArguments: #()) = 5.	"bar on coloredPoint = super bar + super bar"	self assert: (aColoredPoint send: #bar withArguments: #()) = 10.! !!ObjTest methodsFor: 'utilities tests'!testMethodWithHeaderAndBody	"a method simply returning objself"	self assert: ((pointClass					methodWithHeader: ''					andBody: 'objself ') value: 2) = 2.		"a method returning its first none implicit arg"	self assert: ((pointClass 					methodWithHeader: 'val'					andBody: 'val ') value: 2 value: 33) = 33.	"a method returns its superclass of the class defining the method value"	"this anonymous method is defined in pointClass so its superclass pointer is objectClass"	self assert: ((pointClass 					methodWithHeader: ''					andBody: ' superClassOfClassDefiningTheMethod ') value: aPoint) = objectClass .	self assert: ((coloredPointClass 					methodWithHeader: ''					andBody: ' superClassOfClassDefiningTheMethod ') value: aPoint) = pointClass .! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:52'!testNilWhenErrorInLookup	"(self  selector: #testNilWhenErrorInLookup) run"		self assert: (pointClass lookup: #zork) isNil.	"The method zork is NOT implement on pointClass"	! !!ObjTest methodsFor: 'tests' stamp: 'SD 2/5/2013 16:47'!testPrimitiveStructure	"(self selector: #testPrimitiveStructure) run"		self assert: (pointClass objClassId = #ObjClass).	self assert: ((pointClass objName ) = #ObjPoint).	self assert: ((pointClass objSuperclassId ) = #ObjObject).	self assert: ((pointClass objIVs) = #(#class #x #y)).	self assert: ((pointClass objKeywords) = #(#x: #y:)).	self assert: ((pointClass objMethodDict) = nil) not! !!ObjTest methodsFor: 'step1-tests-structure of objects' stamp: 'JB 10/9/2009 10:30'!testPrimitiveStructureObjClassId	"(self selector: #testPrimitiveStructureObjClassId) run"	self assert: (pointClass objClassId = #ObjClass).! !!ObjTest methodsFor: 'step1-tests-structure of objects' stamp: 'SD 2/5/2013 16:48'!testPrimitiveStructureObjClassIdForSimpleObject	"self run: #testPrimitiveStructureObjClassIdForSimpleObject"	self assert: (aPoint objClassId = #ObjPoint).! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:30'!testPrimitiveStructureObjIVs	"(self selector: #testPrimitiveStructureObjIVs) run"	self assert: ((pointClass objIVs) = #(#class #x #y)).! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:30'!testPrimitiveStructureObjKeywords	"(self selector: #testPrimitiveStructureObjKeywords) run"	self assert: ((pointClass objKeywords) = #(#x: #y:)).! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:29'!testPrimitiveStructureObjMethodDict	"(self selector: #testPrimitiveStructureObjMethodDict) run"	self assert: ((pointClass objMethodDict) = nil) not! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:29'!testPrimitiveStructureObjName	"(self selector: #testPrimitiveStructureObjName) run"	self assert: ((pointClass objName ) = #ObjPoint).	! !!ObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'JB 10/9/2009 10:29'!testPrimitiveStructureObjSuperclassId	"(self selector: #testPrimitiveStructureObjSuperclassId) run"	self assert: ((pointClass objSuperclassId ) = #ObjObject).! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 11/21/2015 18:24'!testRaisesErrorSendWhenErrorInLookup	"(self  selector: #testRaisesErrorSendWhenErrorInLookup) run"	self should: [ pointClass send: #zork withArguments: { aPoint } ] raise: Error.	"Open a Transcript to see the message trace"! !!ObjTest methodsFor: 'tests-MessagePassingsAndDynamicsLookup' stamp: 'StephaneDucasse 12/5/2014 17:54'!testSendErrorRaisesErrorSendWhenErrorInLookup	"(self  selector: #testSendErrorRaisesErrorSendWhenErrorInLookup) run"		self should: [  pointClass sendError: #zork withArgs: { aPoint } ] raise: Error.	"Open a Transcript to see the message trace"! !!ObjTestBootstrap methodsFor: 'test ObjClass creation' stamp: 'StephaneDucasse 11/26/2014 21:56'!testCreateObjClassMessage	"(self selector: #testCreateObjClassMessage) run"	| objClass |	Obj bootstrap.	objClass := Obj giveClassNamed: #ObjClass.	self assert: ((objClass send: #class withArguments: #()) = (Obj giveClassNamed: #ObjClass)).	self assert: (objClass send: #isClass withArguments: #()).	self assert: (objClass send: #isMetaclass withArguments: #())! !!ObjTestBootstrap methodsFor: 'test ObjClass creation' stamp: 'StephaneDucasse 11/26/2014 21:57'!testCreateObjClassStructure	"(self selector: #testCreateObjClassStructure) run"	| objClass |	Obj bootstrap.	objClass := Obj giveClassNamed: #ObjClass.	self assert: (objClass objName = #ObjClass).	self assert: (objClass objClassId = #ObjClass).	self assert: (objClass objSuperclassId = #ObjObject).	self assert: (objClass objIVs asArray = #(#class #name #superclass #iv #keywords #methodDict)).	self assert: (objClass objKeywords asArray = #(#name: #superclass: #iv: #keywords: #methodDict:))! !!ObjTestBootstrap methodsFor: 'test ObjObject creation ' stamp: 'StephaneDucasse 11/26/2014 21:59'!testCreateObjObjectInstanceMessage	"(self selector: #testCreateObjObjectInstanceMessage) run"	| pointClass objClass pointInstance |	Obj initialize.	Obj manuallyCreateObjClass.	Obj createObjObject.	objClass := Obj giveClassNamed: #ObjClass.	pointClass := objClass 							send: #new							withArguments: #(#(#name: #ObjPoint #superclass: #ObjObject #iv: #(#x #y))).	pointInstance := pointClass send: #new withArguments: #(#()).	self assert: (pointInstance objClassId = #ObjPoint).	self assert: ((pointInstance send: #getIV withArguments: #(#x)) = nil).	pointInstance send: #setIV withArguments: #(#x 25).	self assert:  ((pointInstance send: #getIV withArguments: #(x)) = 25 )! !!ObjTestBootstrap methodsFor: 'test ObjObject creation ' stamp: 'StephaneDucasse 11/26/2014 22:00'!testCreateObjObjectMessage	"(self selector: #testCreateObjObjectMessage) run"	| objObject |	Obj initialize.	Obj manuallyCreateObjClass.	Obj createObjObject.	objObject := Obj giveClassNamed: #ObjObject.	self assert: (objObject send: #class withArguments: #()) = (Obj giveClassNamed: #ObjClass).	self assert: (objObject send: #isClass withArguments: #()) not.	self assert: (objObject send: #getIV withArguments: #(#class)) = #ObjClass! !!ObjTestBootstrap methodsFor: 'test ObjObject creation ' stamp: 'stephane.ducasse 9/29/2008 14:32'!testCreateObjObjectStructure	"(self selector: #testCreateObjObjectStructure) run"	| objObject |	Obj initialize.	Obj manuallyCreateObjClass.	Obj createObjObject.	objObject := Obj giveClassNamed: #ObjObject.	self assert: (objObject objName = #ObjObject).	self assert: (objObject objClassId = #ObjClass).	self assert: (objObject objSuperclassId isNil).	self assert: (objObject objIVs asArray = #(#class)).	self assert: (objObject objKeywords asArray = #())! !!ObjTestBootstrap methodsFor: 'test ObjClass manual creation ' stamp: 'StephaneDucasse 11/26/2014 22:01'!testManuallyCreateObjClassAllocate	"(self selector: #testManuallyCreateObjClassAllocate) run"	| objClass emptyClass |	Obj initialize.	Obj manuallyCreateObjClass.	objClass := Obj giveClassNamed: #ObjClass.	emptyClass := objClass send: #allocate withArguments: #().	self assert: emptyClass objClassId = #ObjClass.	self assert:  emptyClass objSuperclassId isNil.	self assert:  emptyClass objIVs isNil.	self assert:  emptyClass objKeywords isNil.	self assert:  emptyClass objMethodDict isNil.	self assert:  emptyClass objName isNil! !!ObjTestBootstrap methodsFor: 'test ObjClass manual creation ' stamp: 'StephaneDucasse 11/26/2014 22:01'!testManuallyCreateObjClassStructure	"(self selector: #testManuallyCreateObjClassStructure) run"	| objClass |	Obj initialize.	Obj manuallyCreateObjClass.	objClass := Obj giveClassNamed: #ObjClass.	self assert: (objClass objName = #ObjClass).	self assert: (objClass objClassId = #ObjClass).	self assert: (objClass objClass == objClass).	self assert: (objClass objSuperclassId = #ObjObject).		"the fact that the created first class inherits form ObjObject is not necessary	because there is no super calls"	self assert: (objClass objIVs = #(#class #name #superclass #iv #keywords #methodDict)).	self assert: (objClass objKeywords = #(#name: #superclass: #iv: #keywords: #methodDict:))! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:10'!assembleClassClass	classClass := Obj new: 6.	classClass at: 2 put: #ObjClass.	classClass at: 1 put: #ObjClass.	classClass at: 4 put: #(#class #name #superclass #iv #keywords #methodDict).	classClass at: 5 put: #(#name: #superclass: #iv: #keywords: #methodDict:).	classClass at: 3 put: #ObjObject.	classClass at: 6 put: (IdentityDictionary new).	Obj declareClass: classClass! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:09'!assembleColoredInstance	aColoredPoint := Obj new: 4.	aColoredPoint at: 1 put: #ObjColoredPoint.	aColoredPoint at: 2 put: 10.	aColoredPoint at: 3 put: 15.	aColoredPoint at: 4 put: #blue! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:38'!assembleColoredPointClass	coloredPointClass := Obj new: 6.	coloredPointClass at: 2 put: #ObjColoredPoint.	coloredPointClass at: 1 put: #ObjClass.	"Here the initialize of metaclass is not available so we perform the instance variable lookup by hand."	coloredPointClass at: 4 put: #( #class #x #y #color).	coloredPointClass at: 3 put: #ObjPoint.	coloredPointClass at: 6 put: (IdentityDictionary new).	Obj declareClass: coloredPointClass.	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'I''am a colored point';				cr]] value: pointClass).	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #foo withArguments:#() from: superClassOfClassDefiningTheMethod) + (objself super: #foo withArguments:#() from: superClassOfClassDefiningTheMethod)				]] value: pointClass).	(coloredPointClass at: coloredPointClass offsetForMethodDict) at: #bar		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #bar withArguments:#() from: superClassOfClassDefiningTheMethod) + (objself super: #bar withArguments:#() from: superClassOfClassDefiningTheMethod)]			] value: pointClass).! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:09'!assembleIncrementalColoredInstance		aIncrementalColoredPoint := Obj new: 4.	aIncrementalColoredPoint at: 1 put: #ObjIncrementalColoredPoint.	aIncrementalColoredPoint at: 2 put: 10.	aIncrementalColoredPoint at: 3 put: 15.	aIncrementalColoredPoint at: 4 put: #blue! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/27/2014 20:39'!assembleIncrementalColoredPointClass	incrementalColoredPointClass := Obj new: 6.	incrementalColoredPointClass at: 2 put: #ObjIncrementalColoredPoint.	incrementalColoredPointClass at: 1 put: #ObjClass.	"Some tests will invoke by hand computeIV... so we do not have to hardcode the sequence."	incrementalColoredPointClass at: 4 put: #( #color).	incrementalColoredPointClass at: 3 put: #ObjPoint.	incrementalColoredPointClass at: 6 put: (IdentityDictionary new).	Obj declareClass: incrementalColoredPointClass.	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'I''am a colored point';				cr]] value: pointClass).	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod) + (objself super: #foo withArguments: #() from: superClassOfClassDefiningTheMethod)				]] value: pointClass).	(incrementalColoredPointClass at: incrementalColoredPointClass offsetForMethodDict) at: #bar		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				(objself super: #bar withArguments: #()  from: superClassOfClassDefiningTheMethod) + (objself super: #bar withArguments: #()  from: superClassOfClassDefiningTheMethod)]			] value: pointClass).! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:12'!assembleObjectClass	objectClass := Obj new: 6.	objectClass at: 2 put: #ObjObject.	objectClass at: 1 put: #ObjClass.	objectClass at: objectClass offsetForIVs put: #(#class).	objectClass at: objectClass offsetForKeywords put: #().	objectClass at: objectClass offsetForSuperclass put: nil.	objectClass at: objectClass offsetForMethodDict put: (IdentityDictionary new).	Obj declareClass: objectClass.	"here I simulate by hand the way superclass is captured for super lookup, I value the block with nil for now to represent	the superclass of ObjObject"	(objectClass at: objectClass offsetForMethodDict) at: #print		put: 			([:superClassOfClassDefiningTheMethod |				[:objself | 			Transcript show: 'I''am an Object';				cr]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #error		put: 			([:superClassOfClassDefiningTheMethod |				[:object :selector | 			Transcript show: 'Error: selector ' , selector printString , ' not understood';				cr.				Error signal]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #getIV		put: ([:superClassOfClassDefiningTheMethod | [:object :iv | object valueOfInstanceVariable: iv]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #setIV		put: 			([:superClassOfClassDefiningTheMethod | [:object :iv :val | 			object at: (object offsetFromObjectOfInstanceVariable: iv) put: val]] value: nil).	(objectClass at: objectClass offsetForMethodDict) at: #bar		put: 			([:superClassOfClassDefiningTheMethod | [:objself | 					5]] value: nil).! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:13'!assemblePointClass	| cl |	cl := Obj giveClassNamed: #ObjClass.	pointClass := Obj new: (cl at: cl offsetForIVs) size.	pointClass at: 2 put: #ObjPoint.	pointClass at: 1 put: #ObjClass.	pointClass at: 4 put: #(#class #x #y).	pointClass at: 5 put: #(#x: #y:).	pointClass at: 3 put: #ObjObject.	pointClass at: 6 put: (IdentityDictionary new).	Obj declareClass: pointClass.	(pointClass at: pointClass offsetForMethodDict) at: #x		put: ([ :superClassOfClassDefiningTheMethod | [:objself | objself valueOfInstanceVariable: #x]] value: objectClass).	(pointClass at: pointClass offsetForMethodDict) at: #print		put: 			([ :superClassOfClassDefiningTheMethod | [:objself | 			Transcript show: 'I''am a Point';				cr]] value: objectClass).	(pointClass at: pointClass offsetForMethodDict) at: #foo		put: 			([ :superClassOfClassDefiningTheMethod | 				[:objself | 				Transcript show: 'ObjPoint>>foo';cr.				5				]] value: objectClass)! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:09'!assemblePointInstance	aPoint := Obj new: 3.	aPoint at: 1 put: #ObjPoint.	aPoint at: 2 put: 10.	aPoint at: 3 put: 15! !!RawObjTest methodsFor: 'setup' stamp: 'StephaneDucasse 11/17/2014 11:09'!setUp	"self new setUp"	Obj initialize.	self assembleClassClass.	self assemblePointClass.	self assembleObjectClass.	self assembleColoredPointClass.	self assemblePointInstance.	self assembleColoredInstance.	self assembleIncrementalColoredInstance.	self assembleIncrementalColoredPointClass! !!RawObjTest methodsFor: 'step3-tests-class access' stamp: 'StephaneDucasse 11/17/2014 11:09'!testClassAccess	"(self  selector: #testClassAccess) run"		self assert: (aPoint objClass = pointClass)! !!RawObjTest methodsFor: 'step1-tests-structure of objects' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjClassId	"(self selector: #testPrimitiveStructureObjClassId) run"	self assert: (pointClass objClassId = #ObjClass).! !!RawObjTest methodsFor: 'step1-tests-structure of objects' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjClassIdForSimpleObject	"self run: #testPrimitiveStructureObjClassIdForSimpleObject"	self assert: (aPoint objClassId = #ObjPoint).! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjIVs	"(self selector: #testPrimitiveStructureObjIVs) run"	self assert: ((pointClass objIVs) = #(#class #x #y)).! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjKeywords	"(self selector: #testPrimitiveStructureObjKeywords) run"	self assert: ((pointClass objKeywords) = #(#x: #y:)).! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjMethodDict	"(self selector: #testPrimitiveStructureObjMethodDict) run"	self assert: ((pointClass objMethodDict) = nil) not! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjName	"(self selector: #testPrimitiveStructureObjName) run"	self assert: ((pointClass objName ) = #ObjPoint).	! !!RawObjTest methodsFor: 'step2-tests-structure of classes' stamp: 'StephaneDucasse 11/17/2014 11:09'!testPrimitiveStructureObjSuperclassId	"(self selector: #testPrimitiveStructureObjSuperclassId) run"	self assert: ((pointClass objSuperclassId ) = #ObjObject).! !!Obj class methodsFor: 'bootstrap objMessage' stamp: 'StephaneDucasse 1/1/2018 20:14'!addMessagesForErrorHandling	"pre condition message has been created (and declared)"	"self addMessagesForErrorHandling"	| objMessage |	objMessage := self ObjMessage.	objMessage 		addUnaryMethod: #receiver 		withBody: 'objself valueOfInstanceVariable: #receiver'.	objMessage 		addUnaryMethod: #receiver2 		withBody: 'objself send: #getIV withArguments: #(#receiver)'.	objMessage 		addUnaryMethod: #selector 		withBody: 'objself send: #getIV withArguments: #(#selector)'.			objMessage 		addUnaryMethod: #arguments 		withBody: 'objself send: #getIV withArguments: #(#arguments)'.		objMessage 		addMethod: #setReceiver		args: 'receiver'		withBody:' objself send: #setIV withArguments: (Array with: #receiver with: receiver)'.			objMessage 		addMethod: #setSelector		args: 'selector'		withBody:' objself send: #setIV withArguments: (Array with: #selector with: selector)'.	objMessage 		addMethod: #setArguments		args: 'arguments'		withBody:' objself send: #setIV withArguments: (Array with: #arguments with: arguments)'.							^ objMessage ! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 1/1/2018 20:14'!bootstrap	"self bootstrap"		self initialize.	self manuallyCreateObjClass.	self createObjObject.	self createObjClass.! !!Obj class methodsFor: 'meta data' stamp: 'StephaneDucasse 1/1/2018 20:14'!classInstanceVariables	^ #(#class #name #superclass #iv #keywords #methodDict)! !!Obj class methodsFor: 'bootstrap objClass' stamp: 'StephaneDucasse 1/1/2018 20:14'!createObjClass	"self bootstrap"	| objClass |	objClass := self objClassStructure.	self defineAllocateMethodIn: objClass.	self defineNewMethodIn: objClass.	self defineInitializeMethodIn: objClass.	objClass 		addUnaryMethod: #isMetaclass		withBody: 'objself objIVs includes: #superclass'.		"an object is a class if is class is a metaclass. cool"		objClass 		addUnaryMethod: #isClass		withBody: 'objself objClass send: #isMetaclass withArguments:#()'.	^objClass! !!Obj class methodsFor: 'bootstrap objObject' stamp: 'StephaneDucasse 1/1/2018 20:14'!createObjObject	| objObject |	objObject := self objObjectStructure.	objObject addUnaryMethod: #class withBody: 'objself objClass'.	objObject addUnaryMethod: #isClass withBody: 'false'.	objObject addUnaryMethod: #isMetaclass withBody: 'false'. 	objObject 		addMethod: #error		args: 'arrayOfArguments'		withBody: 'Transcript show: ''error '', arrayOfArguments first.  ''error '', arrayOfArguments first'.	"some meta facilities"	objObject 		addMethod: #getIV		args: 'iv'		withBody: 'objself valueOfInstanceVariable: iv'.	objObject 		addMethod: #setIV		args: 'iv val'		withBody: 			' objself at: (objself offsetFromObjectOfInstanceVariable: iv) put: val'.	objObject 		addMethod: #initialize		args: 'initargs'		withBody: 'objself  initializeUsing: initargs'.	^objObject! !!Obj class methodsFor: 'global class repository management' stamp: 'StephaneDucasse 1/1/2018 20:14'!declareClass: anObjClass 	"To declare an ObjClass in the class repository"	| nameC |	nameC := anObjClass objName.	nameC isNil		ifFalse: [definedObjClasses at: nameC put: anObjClass]		ifTrue: [self error: 'The class does not have a name']! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 1/1/2018 20:14'!defineAllocateMethodIn: class 	"The allocated obj method simply invokes the primitive allocateAnInstance."		class 		addUnaryMethod: #allocate 		withBody: 'objself allocateAnInstance'! !!Obj class methodsFor: 'bootstrap objClass' stamp: 'StephaneDucasse 1/1/2018 20:14'!defineInitializeMethodIn: objClass 	objClass 		addMethod: #initialize		args: 'initArray'		withBody: 			'objself super: #initialize withArguments: {initArray} from: superClassOfClassDefiningTheMethod.			objself objIVs: (objself							computeNewIVFrom: (Obj giveClassNamed: objself objSuperclassId) objIVs							with: objself objIVs).			objself computeAndSetKeywords.			objself objMethodDict: IdentityDictionary new.			Obj declareClass: objself.			objself'! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 1/1/2018 20:14'!defineManualInitializeMethodIn: class 	class 		addMethod: #initialize		args: 'initArray'		withBody: 				'| objsuperclass |			objself initializeUsing: initArray.	"Initialize a class as an object. In the bootstrapped system will be done via super"			objsuperclass := Obj giveClassNamed: objself objSuperclassId ifAbsent: [nil].			objsuperclass isNil				ifFalse: 					[objself						objIVs: (objself computeNewIVFrom: objsuperclass objIVs with: objself objIVs)]				ifTrue: 					[objself objIVs: (objself computeNewIVFrom: #(#class) with: objself objIVs)].			objself				objKeywords: (objself generateKeywords: (objself objIVs copyWithout: #class)).			objself objMethodDict: (IdentityDictionary new: 3).			Obj declareClass: objself.			objself'! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 1/1/2018 20:14'!defineNewMethodIn: class 	class 		addMethod: #new		args: 'initArray'		withBody: 			'(objself send: #allocate withArguments: #()) send: #initialize withArguments: { initArray } '.! !!Obj class methodsFor: 'tricks' stamp: 'StephaneDucasse 1/1/2018 20:14'!doesNotUnderstand: aMessage	"debugging >>>  default shiftDown ifTrue:[ self halt ]."	"Sensor shiftPressed ifTrue:[ self halt ]."		^ definedObjClasses at: aMessage selector! !!Obj class methodsFor: 'global class repository management' stamp: 'StephaneDucasse 1/1/2018 20:14'!giveClassNamed: aSymbol 	"Return the class defined in the class repository with the name aSymbol"	^ self giveClassNamed: aSymbol ifAbsent: [self error: ('The class ' , aSymbol printString , ' is not defined')]! !!Obj class methodsFor: 'global class repository management' stamp: 'StephaneDucasse 1/1/2018 20:14'!giveClassNamed: aSymbol ifAbsent: aBlock	^ definedObjClasses at: aSymbol ifAbsent: aBlock! !!Obj class methodsFor: 'initialize' stamp: 'StephaneDucasse 1/1/2018 20:14'!initialize	"self initialize"	 	definedObjClasses := IdentityDictionary new.	definedObjClasses at: #ObjClass put: nil.	definedObjClasses at: #ObjObject put: nil.	definedObjClasses at: #ObjMessage put: nil.! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 1/1/2018 20:14'!manualObjClassStructure	| class |	class := Obj new: 6.	class objClassId: #ObjClass.	class objName: #ObjClass.	class objIVs: self classInstanceVariables.	class objKeywords: #(#name: #superclass: #iv: #keywords: #methodDict:).	class objSuperclassId: #ObjObject.	class objMethodDict: (IdentityDictionary new: 3).	^ class! !!Obj class methodsFor: 'bootstrap objClass manually' stamp: 'StephaneDucasse 1/1/2018 20:14'!manuallyCreateObjClass	"self manuallyCreateObjClass"	| class |	class := self manualObjClassStructure.	Obj declareClass: class.	self defineManualInitializeMethodIn: class.	self defineNewMethodIn: class.	self defineAllocateMethodIn: class.	^class! !!Obj class methodsFor: 'bootstrap objClass' stamp: 'StephaneDucasse 1/1/2018 20:14'!objClassStructure	^(Obj giveClassNamed: #ObjClass) send: #new		withArguments: #(#(#name: #ObjClass #iv: #(#name #superclass #iv #keywords #methodDict) #superclass: #ObjObject))! !!Obj class methodsFor: 'bootstrap objMessage' stamp: 'StephaneDucasse 1/1/2018 20:14'!objClassStructureMessage	^ Obj ObjClass 		send: #new		withArguments: #(#(#name: #ObjMessage #iv: #(#receiver #selector #arguments) #superclass: #ObjObject))! !!Obj class methodsFor: 'bootstrap objObject' stamp: 'StephaneDucasse 1/1/2018 20:14'!objObjectStructure	^(Obj giveClassNamed: #ObjClass) 		send: #new		withArguments: #(#(#name: #ObjObject #iv: #(#class)))! !!Obj class methodsFor: 'skeleton metadata' stamp: 'StephaneDucasse 1/1/2018 20:14'!selectorsToSkeletonize	"Skeletonizer new 		selectors: Obj selectorsToSkeletonize;		sourceClassName: #Obj;		targetClassName: #ObjSkeleton;		installClass;		skeletonize		"	^ #(objIVs objIVs: objKeywords objKeywords: objMethodDict objMethodDict: objName objName: objSuperclassId objSuperclassId: objClass objClassId objClassId: allocateAnInstance offsetFromClassOfInstanceVariable: offsetFromObjectOfInstanceVariable: valueOfInstanceVariable: #send:withArguments: #super:withArguments:from: lookup: bodyOfMethod:)! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!addMethod: aSelector args: aString withBody: aStringBlock 	"Define a method with selector <aSelector> , having a string representing the arguments (ie 'aNumber aStream') 	and a string representing the method body in the receiver.	If a method with the same selector already existed, the new definition will erase it.	self is an objClass"	self  objMethodDict at: aSelector put: (self methodWithHeader: aString andBody: aStringBlock).	^self! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!addUnaryMethod: aSelector withBody: aStringBlock 	"Define a unary method with selector <aSelector> and a body <aaStringBlock> in the receiver.	If a method with the same selector already existed, the new definition will erase it.	self is an objClass"	self  addMethod: aSelector args: '' withBody: aStringBlock! !!Obj methodsFor: 'instance allocation' stamp: 'StephaneDucasse 1/1/2018 20:14'!allocateAnInstance	"Returns a newly created instance of self, an ObjClass. In this implementation the identifier of the object class is the name of the class. "	^ self! !!Obj methodsFor: 'message passing' stamp: 'StephaneDucasse 1/1/2018 20:14'!basicSend: selector withArguments: arguments from: aClass	"Execute the method found starting from aClass and whose name is selector."	"The core of the sending a message, reused for both a normal send or a super one."		| methodOrNil |	methodOrNil := aClass lookup: selector.	^ methodOrNil 		ifNotNil: [ methodOrNil valueWithArguments: (Array with: self) , arguments ] 		ifNil: [ self sendError: selector withArgs: arguments ] ! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!blockArgsFrom: aCol	"self basicNew blockArgsFrom: ' abc def ghi '"			| col st |	col := aCol findTokens: Character space.	col := col copyWithout: ''.	st := ''.	col do: [ :each | st := st , ':', each ] separatedBy: [st := st, ' '].	^ st! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!bodyOfMethod: aSelector	"Return the method associated with the selector <aSelector> in the receiver.	Return nil if the selector is not defined.  self is an objClass"	^ self! !!Obj methodsFor: 'debugging' stamp: 'StephaneDucasse 1/1/2018 20:14'!classDebug	"(self giveClassNamed: #ObjClass) classDebug"	"(self giveClassNamed: #ObjSet) classDebug"	ObjClassInspector basicInspect: self! !!Obj methodsFor: 'keyword management' stamp: 'StephaneDucasse 1/1/2018 20:14'!computeAndSetKeywords	"Compute the keywords of a given class.  As the class of an object should not be changed.	 the keywords should note contain the keyword class. self is anObjClass"	self objKeywords: (self generateKeywords: (self objIVs copyWithout: #class))! !!Obj methodsFor: 'iv inheritance' stamp: 'StephaneDucasse 1/1/2018 20:14'!computeNewIVFrom: superIVOrdCol with: localIVOrdCol	"Returns an ordered collection that is the union without duplicate of ivOfSuper and ivOrderedCollection.	Important the order of the instance variable is conserved"	| ivs |	^superIVOrdCol isNil 		ifTrue: [localIVOrdCol]		ifFalse: 			[ivs := superIVOrdCol asOrderedCollection copy.			localIVOrdCol do: [:e | (ivs includes: e) ifFalse: [ivs add: e]].			ivs]! !!Obj methodsFor: 'iv inheritance' stamp: 'StephaneDucasse 1/1/2018 20:14'!computeNewIVFromClass: anObjClass with: ivOrderedCollection 	"Obj computeNewIVFromClass: #(#C #C #O #(a b c d)) with: #(a z b t) asOrderedCollection"	| ivs |	^anObjClass isNil		ifTrue: [ivOrderedCollection]		ifFalse: 			[ivs := anObjClass objIVs asOrderedCollection copy.			ivOrderedCollection do: [:e | (ivs includes: e) ifFalse: [ivs add: e]].			ivs]! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!doesUnderstand: aSelector 	"Tell if the receiver has a method having <aSelector> as selector. self is anObjClass"	^self objMethodDict keys includes: aSelector! !!Obj methodsFor: 'keyword management' stamp: 'StephaneDucasse 1/1/2018 20:14'!generateKeywords: anArray 	"Returns an array containing the keywords made from the collection of Symbol passed as argument"	"self new generateKeywords: #(titi toto lulu) "	^anArray collect: [:e | (e , ':') asSymbol]! !!Obj methodsFor: 'instance initialization' stamp: 'StephaneDucasse 1/1/2018 20:14'!initializeUsing: anAlternatedArray 	"Returns the receiver an ObjObject initialized according to the directives given by anAlternateArray"	| ivValues |	ivValues := self 						returnValuesFrom: anAlternatedArray						followingSchema: self objClass objKeywords.	1 to:  ivValues size			do: [:i | self at: i + 1 put: (ivValues at: i)].	^ self ! !!Obj methodsFor: 'keyword management' stamp: 'StephaneDucasse 1/1/2018 20:14'!keywordValue: aSymbol getFrom: anArray ifAbsent: aDefaultValue 	"precondition: ((length anArray) mod 2) = 0 	returns the value associated with the keyword represented by aSymbol 	in the initarg list represented by anArray."	"self new keywordValue: #titi getFrom: #(toto 12 titi 23) ifAbsent: 2"	"self new keywordValue: #titi getFrom: #(toto 23) ifAbsent: 2"	| i |	i := anArray indexOf: aSymbol ifAbsent: nil.	^i isNil 		ifTrue: [aDefaultValue] 		ifFalse: [anArray at: i + 1]! !!Obj methodsFor: 'method lookup' stamp: 'StephaneDucasse 1/1/2018 20:14'!lookup: selector	"look for the method named <selector> starting in the receiver. 	The lookup is done for a message sent to <anObjObject>. self is an objClass"	^ self! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!methodWithHeader: col andBody: aString 	| block string resBlock |	string := self stringOfBlockBodyFromHeader: col andBody: aString.	block := Compiler evaluate: string.	"bind superclass to the superclass of the class defining the method"	resBlock := block value: (Obj giveClassNamed: self objSuperclassId ifAbsent: [666]).	^resBlock! !!Obj methodsFor: 'iv management' stamp: 'StephaneDucasse 1/1/2018 20:14'!numberOfIVs	"Returns the number of instance variables of the class an ObjClass"	^self objIVs size! !!Obj methodsFor: 'object structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objClass	"Receiver should be: anObjObject. Returns the class of the receiver (which is an ObjObject) and not its internal identification. Differs from classId  which is a primitive to access the structure representing a class"	^ self! !!Obj methodsFor: 'object structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objClassId	"Receiver should be: anObjObject. Returns the identifier that identifies the class of the receiver (an objObject). In this implementation we chose to use the class name as identifier"	^ self! !!Obj methodsFor: 'object structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objClassId: anObjClassId	"Receiver should be: anObjObject. Set the identifier that identifies the class of the receiver (anObjObject)."	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objIVs	"Receiver should be: anObjClass. Returns the list of instance variables"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objIVs: anOrderedCollection	"Receiver should be: anObjClass. Set the list of instance variable names of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objKeywords	"Receiver should be: anObjClass. Returns the keyword list of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objKeywords: anOrderedCollection	"Receiver should be: anObjClass. Sets the list of keywords of the receiver (anObjClass). Note that this method is just an accessor and does not compute the actual list of keywords"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objMethodDict	"Receiver should be: anObjClass. Returns the method dictionary of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objMethodDict: aDictionary	"Receiver should be: anObjClass. Sets the method dictionary of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objName	"Receiver should be: anObjClass. Returns the name of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objName: aName	"Receiver should be: anObjClass. Set the name of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objSuperclass	"Receiver should be: anObjClass. Returns the superclass of the receiver (which is an objClass) and not its internal identification. Differs from superclassId which is a primitive to access the structure representing a class"	^Obj giveClassNamed: self objSuperclassId! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objSuperclassId	"Receiver should be: anObjClass. Returns the superclass id of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'class structure primitive' stamp: 'StephaneDucasse 1/1/2018 20:14'!objSuperclassId: anObjClassId	"Receiver should be: anObjClass. Set the superclass id of the receiver (anObjClass)"	^ self! !!Obj methodsFor: 'object structure offset' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetForClass	^1! !!Obj methodsFor: 'class structure offset' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetForIVs	^4! !!Obj methodsFor: 'class structure offset' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetForKeywords	^5! !!Obj methodsFor: 'class structure offset' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetForMethodDict	^6! !!Obj methodsFor: 'class structure offset' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetForName	^2! !!Obj methodsFor: 'class structure offset' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetForSuperclass	^3! !!Obj methodsFor: 'iv management' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetFromClassOfInstanceVariable: aSymbol	"Returns the index of the instance variable named aSymbol for an class anObjClass.	Returns 0 if the aSymbol is not present in the instance variable lists of anObjClass"	^ self! !!Obj methodsFor: 'keyword management' stamp: 'StephaneDucasse 1/1/2018 20:14'!offsetFromObjectOfInstanceVariable: aSymbol	"Returns the offset of the instance variable named aSymbol in the object anObjObject.	If aSymbol is not an instance variable is not an instance variable of the object raise an error"	^ self! !!Obj methodsFor: 'printing' stamp: 'StephaneDucasse 1/1/2018 20:14'!printOn: aStream	aStream nextPutAll: 'an Obj object: '.		super printOn: aStream! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!removeMethod: aSelector	"Remove the method with aSelector <aSymbol> in the receiver. 	self is an objClass"	self objMethodDict removeKey: aSelector ifAbsent: [].	^self! !!Obj methodsFor: 'keyword management' stamp: 'StephaneDucasse 1/1/2018 20:14'!returnValuesFrom: anInitargArray followingSchema: anArrayOfKeywords 	"Return the values associated with the keys. The extracted values are taken from <anInitargArray> 	and the return values are extracted according to the schema defined by the collection of keys <anArrayOfKeywords>"	"self new returnValuesFrom: #(lulu 22  titi 35)  followingSchema: #(titi toto lulu titi)  #(35 nil 22 35)"	^anArrayOfKeywords collect: 			[:e | 			self keywordValue: e				getFrom: anInitargArray 				ifAbsent: nil]! !!Obj methodsFor: 'message passing' stamp: 'StephaneDucasse 1/1/2018 20:14'!send: selector withArguments: arguments	"send the message whose selector is <selector> to the receiver. The arguments of the messages are an array <arguments>. The method is lookep up in the class of the receiver. self is an objObject or a objClass."	^ self! !!Obj methodsFor: 'message passing' stamp: 'StephaneDucasse 1/1/2018 20:14'!sendError: selector withArgs: arguments	"send error wrapping arguments into an array with the selector as first argument. Instead of an array we should create a message object."		^ self send: #error withArguments:  {(arguments copyWithFirst: selector)}	! !!Obj methodsFor: 'method management' stamp: 'StephaneDucasse 1/1/2018 20:14'!stringOfBlockBodyFromHeader: col andBody: aString 	^ '[ :superClassOfClassDefiningTheMethod |		[ :objself ' , (self blockArgsFrom: col) , ' |					 ' , aString , '] ]'! !!Obj methodsFor: 'message passing' stamp: 'StephaneDucasse 1/1/2018 20:14'!super: selector withArguments: arguments from: aSuperclass	"Invoke an oveeriden method named <selector> with an array of arguments <arguments>.  self is an objClass. aSuperclass should be the superclass of the class containing the method using super"	^ self! !!Obj methodsFor: 'iv management' stamp: 'StephaneDucasse 1/1/2018 20:14'!valueOfInstanceVariable: aSymbol	^ self! !!StrictlyOrderedEyeElement methodsFor: 'accessing' stamp: 'StephaneDucasse 11/16/2014 23:08'!orderedStructure		^ orderedStructure! !!StrictlyOrderedEyeElement methodsFor: 'accessing' stamp: 'StephaneDucasse 11/16/2014 23:08'!orderedStructure: anObject		orderedStructure := anObject! !!StrictlyOrderedEyeElement methodsFor: 'accessing' stamp: 'StephaneDucasse 11/16/2014 23:08'!value	^ self host basicAt: (self orderedStructure indexOf: index)! !!ObjClassInspector methodsFor: 'list' stamp: 'StephaneDucasse 11/16/2014 23:10'!addVariableFields: elements		| classStructure |	classStructure := Obj classInstanceVariables.	classStructure do: [ :key |		elements add: (StrictlyOrderedEyeElement new 								orderedStructure: classStructure;								host: self object;								index: key; 								yourself)]! !"ObjVSkeleton"!!Obj methodsFor: 'object structure primitive' stamp: 'Anonymous 12/2/2024 15:15' prior: 33685792!objClassId	"Receiver should be: anObjObject. Returns the identifier that identifies the class of the receiver (an objObject). In this implementation we chose to use the class name as identifier"	^ self at: self offsetForClass ! !!Obj methodsFor: 'class structure primitive' stamp: 'Elliot 12/2/2024 15:27' prior: 33687665!objName	"Receiver should be: anObjClass. Returns the name of the receiver (anObjClass)"	^ self at: 2! !!Obj methodsFor: 'class structure primitive' stamp: 'Elliot 12/2/2024 15:28' prior: 33687852!objName: aSymbol    self at: 2 put: aSymbol! !!Obj methodsFor: 'class structure primitive' stamp: 'Elliot 12/2/2024 15:28' prior: 33688415!objSuperclassId    ^ self at: 3! !!Obj methodsFor: 'class structure primitive' stamp: 'Elliot 12/2/2024 15:29' prior: 33688619!objSuperclassId: aSymbol    self at: 3 put: aSymbol! !!Obj methodsFor: 'class structure primitive' stamp: 'Elliot 12/2/2024 15:29' prior: 33686322!objIVs    ^ self at: 4! !!Obj methodsFor: 'class structure primitive' stamp: 'Elliot 12/2/2024 15:29' prior: 33686501!objIVs: anOrderedCollection    self at: 4 put: anOrderedCollection! !!Obj methodsFor: 'class structure primitive' stamp: 'Elliot 12/2/2024 15:30' prior: 33686731!objKeywords    ^ self at: 5! !!Obj methodsFor: 'class structure primitive' stamp: 'Elliot 12/2/2024 15:31' prior: 33686930!objKeywords: anOrderedCollection    self at: 5 put: anOrderedCollection! !!Obj methodsFor: 'class structure primitive' stamp: 'Elliot 12/2/2024 15:31' prior: 33687243!objMethodDict    ^ self at: 6! !!Obj methodsFor: 'class structure primitive' stamp: 'Elliot 12/2/2024 15:31' prior: 33687449!objMethodDict: anIdentityDictionary    self at: 6 put: anIdentityDictionary! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 15:38' prior: 33689467!offsetFromClassOfInstanceVariable: aSymbol    ^ (self objIVs indexOf: aSymbol) ifNil: [ 0 ].! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 15:41' prior: 33692353!valueOfInstanceVariable: aSymbol    | offset |    offset := self offsetFromObjectOfInstanceVariable: aSymbol.    ^ offset > 0 ifTrue: [ self at: offset ] ifFalse: [ nil ].! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 15:43'!valueOfInstanceVariable: aSymbol put: aValue    | offset |    offset := self offsetFromObjectOfInstanceVariable: aSymbol.    offset > 0 ifTrue: [ self at: offset put: aValue ].! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 15:44' prior: 33689772!offsetFromObjectOfInstanceVariable: aSymbol    ^ (self objClass offsetFromClassOfInstanceVariable: aSymbol) + 1.! !Obj removeSelector: #offsetFromObjectOfInstanceVariable:!!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 15:46'!offsetFromObjectOfInstanceVariable: aSymbol    ^ (self objClass offsetFromClassOfInstanceVariable: aSymbol) + 1.! !Obj removeSelector: #offsetFromObjectOfInstanceVariable:!Obj removeSelector: #valueOfInstanceVariable:put:!!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 15:48'!offsetFromObjectOfInstanceVariable: aSymbol    ^ (self objClass offsetFromClassOfInstanceVariable: aSymbol) + 1.! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 15:52' prior: 33695166!offsetFromClassOfInstanceVariable: aSymbol    ^ (self objIVs indexOf: aSymbol) ifNil: [ 0 ].! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 15:52' prior: 33696395!offsetFromObjectOfInstanceVariable: aSymbol    ^ (self objClass offsetFromClassOfInstanceVariable: aSymbol) + 1.! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 15:53' prior: 33695346!valueOfInstanceVariable: aSymbol    | offset |    offset := self offsetFromObjectOfInstanceVariable: aSymbol.    ^ offset > 0 ifTrue: [ self at: offset ] ifFalse: [ nil ].! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 15:58' prior: 33696595!offsetFromClassOfInstanceVariable: aSymbol    ^ (self objIVs indexOf: aSymbol) ifNil: [ 0 ].! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 15:58' prior: 33696775!offsetFromObjectOfInstanceVariable: aSymbol    ^ (self objClass offsetFromClassOfInstanceVariable: aSymbol) + 1.! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 15:58' prior: 33696975!valueOfInstanceVariable: aSymbol    | offset |    offset := self offsetFromObjectOfInstanceVariable: aSymbol.    ^ offset > 0 ifTrue: [ self at: offset ] ifFalse: [ nil ].! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 16:11' prior: 33697416!offsetFromObjectOfInstanceVariable: aSymbol    ^ (self objClass offsetFromClassOfInstanceVariable: aSymbol).! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 16:11' prior: 33697877!offsetFromObjectOfInstanceVariable: aSymbol    ^ (self objClass offsetFromClassOfInstanceVariable: aSymbol) + 1.! !!ObjTest methodsFor: 'setup' stamp: 'Elliot 12/2/2024 16:16' prior: 33640565!setUp	"self new setUp"	Compiler := OpalCompiler.	Obj initialize.	self assembleClassClass.	self assemblePointClass.	self assembleObjectClass.	self assembleColoredPointClass.	self assemblePointInstance.	self assembleColoredInstance.	self assembleIncrementalColoredInstance.	self assembleIncrementalColoredPointClass! !----QUIT----2024-12-02T16:20:34.053835+01:00 Pharo 8.0 - 64bit.image priorSource: 3321!!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 16:36' prior: 33697616!valueOfInstanceVariable: aSymbol    "Receiver should be: anObjInstance. Returns the value of the instance variable represented     by aSymbol."    | offset |    offset := self offsetFromObjectOfInstanceVariable: aSymbol. "Obtenir l'offset"    ^ self at: offset! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 16:37' prior: 33698073!offsetFromObjectOfInstanceVariable: aSymbol    "Receiver should be: anObjInstance. Returns the offset of the instance variable represented     by aSymbol. Raises an error if the variable does not exist."    | class offset |    class := self objClass. "Obtenir la classe de l'instance"    offset := class offsetFromClassOfInstanceVariable: aSymbol. "Obtenir l'offset"    offset = 0 ifTrue: [self error: 'Instance variable does not exist'].    ^ offset! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 16:37' prior: 33699120!offsetFromObjectOfInstanceVariable: aSymbol    | class offset |    class := self objClass.     offset := class offsetFromClassOfInstanceVariable: aSymbol.     offset = 0.    ^ offset! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 16:37' prior: 33699664!offsetFromObjectOfInstanceVariable: aSymbol    | class offset |    class := self objClass.     offset := class offsetFromClassOfInstanceVariable: aSymbol.     ^ offset! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 16:39' prior: 33697236!offsetFromClassOfInstanceVariable: aSymbol    | ivList |    ivList := self objIVs.     ^ ivList := ivList indexOf: aSymbol.! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 16:39' prior: 33700196!offsetFromClassOfInstanceVariable: aSymbol    "Receiver should be: anObjClass. Returns the offset of the instance variable represented     by aSymbol. Returns 0 if the variable does not exist."    | ivList index |    ivList := self objIVs. "Liste des variables d'instance"    index := ivList indexOf: aSymbol ifAbsent: [^ 0]. "Retourne 0 si la variable n'existe pas"    ^ index! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 16:40' prior: 33700409!offsetFromClassOfInstanceVariable: aSymbol    | ivList index |    ivList := self objIVs.     index := ivList indexOf: aSymbol .    ^ index! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 16:40' prior: 33700879!offsetFromClassOfInstanceVariable: aSymbol    | ivList  |    ivList := self objIVs.     ^ ivList := ivList indexOf: aSymbol .    ! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 16:45' prior: 33699938!offsetFromObjectOfInstanceVariable: aSymbol    | class offset |    class := self objClass.     offset := class offsetFromClassOfInstanceVariable: aSymbol. 	 offset := 0.    ^ offset! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 16:45' prior: 33698768!valueOfInstanceVariable: aSymbol    | offset |    offset := self offsetFromObjectOfInstanceVariable: aSymbol.     ^ self at: offset! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 16:47' prior: 33701108!offsetFromClassOfInstanceVariable: aSymbol    "Receiver should be: anObjClass. Returns the offset of the instance variable represented     by aSymbol. Returns 0 if the variable does not exist."    | ivList index |    ivList := self objIVs. "Liste des variables d'instance"    index := ivList indexOf: aSymbol ifAbsent: [^ 0]. "Retourne 0 si la variable n'existe pas"    ^ index! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 16:47' prior: 33701822!offsetFromClassOfInstanceVariable: aSymbol    | ivList  |    ivList := self objIVs.     ^ ivList := ivList indexOf: aSymbol .! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 16:59' prior: 33701601!valueOfInstanceVariable: aSymbol    "Receiver should be: anObjInstance. Returns the value of the instance variable represented     by aSymbol."    | offset |    offset := self offsetFromObjectOfInstanceVariable: aSymbol. "Obtenir l'offset"    ^ self at: offset! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 16:59' prior: 33701328!offsetFromObjectOfInstanceVariable: aSymbol    "Receiver should be: anObjInstance. Returns the offset of the instance variable represented     by aSymbol. Raises an error if the variable does not exist."    | class offset |    class := self objClass. "Obtenir la classe de l'instance"    offset := class offsetFromClassOfInstanceVariable: aSymbol. "Obtenir l'offset"    offset = 0 ifTrue: [self error: 'Instance variable does not exist'].    ^ offset! !!Obj methodsFor: 'instance allocation' stamp: 'Elliot 12/2/2024 17:01' prior: 33680215!allocateAnInstance	"Returns a newly created instance of self, an ObjClass. In this implementation the identifier of the object class is the name of the class. "	| newI |	newI := Obj new: (self numberOfIVs ).	newI objClassId: (self objName).	^newI! !!Obj methodsFor: 'class structure primitive' stamp: 'Elliot 12/2/2024 17:09' prior: 33694137!objSuperclassId: aSymbol    self at: self offsetForSuperclass  put: aSymbol! !!Obj methodsFor: 'class structure primitive' stamp: 'Elliot 12/2/2024 17:09' prior: 33694006!objSuperclassId    ^ self at: self offsetForSuperclass ! !!Obj methodsFor: 'class structure primitive' stamp: 'Elliot 12/2/2024 17:09' prior: 33693863!objName: aSymbol    self at: self offsetForName put: aSymbol! !!Obj methodsFor: 'class structure primitive' stamp: 'Elliot 12/2/2024 17:09' prior: 33693662!objName	"Receiver should be: anObjClass. Returns the name of the receiver (anObjClass)"	^ self at: self offsetForName ! !!Obj methodsFor: 'class structure primitive' stamp: 'Elliot 12/2/2024 17:09' prior: 33695003!objMethodDict: anIdentityDictionary    self at: self offsetForMethodDict  put: anIdentityDictionary! !!Obj methodsFor: 'class structure primitive' stamp: 'Elliot 12/2/2024 17:09' prior: 33694874!objMethodDict    ^ self at: self offsetForMethodDict ! !!Obj methodsFor: 'class structure primitive' stamp: 'Elliot 12/2/2024 17:09' prior: 33694703!objKeywords: anOrderedCollection    self at: self offsetForKeywords  put: anOrderedCollection! !!Obj methodsFor: 'class structure primitive' stamp: 'Elliot 12/2/2024 17:09' prior: 33694576!objKeywords    ^ self at: self offsetForKeywords ! !!Obj methodsFor: 'class structure primitive' stamp: 'Elliot 12/2/2024 17:09' prior: 33694410!objIVs: anOrderedCollection    self at: self offsetForIVs  put: anOrderedCollection! !!Obj methodsFor: 'class structure primitive' stamp: 'Elliot 12/2/2024 17:09' prior: 33694288!objIVs    ^ self at: self offsetForIVs ! !!Obj methodsFor: 'object structure primitive' stamp: 'Elliot 12/2/2024 17:13' prior: 33686087!objClassId: anObjClassId	"Receiver should be: anObjObject. Set the identifier that identifies the class of the receiver (anObjObject)."	^ self at: (self offsetForClass) put: anObjClassId  ! !!Obj methodsFor: 'object structure primitive' stamp: 'Elliot 12/2/2024 17:13' prior: 33685465!objClass	"Receiver should be: anObjObject. Returns the class of the receiver (which is an ObjObject) and not its internal identification. Differs from classId  which is a primitive to access the structure representing a class"	^ self offsetForClass ! !!Obj methodsFor: 'object structure primitive' stamp: 'Elliot 12/2/2024 17:23' prior: 33705776!objClass    "Receiver should be: anObjObject. Returns the class of the receiver (which is an ObjObject) and not its internal identification. Differs from classId  which is a primitive to access the structure representing a class"    "self class == Obj"    ^ (self class) giveClassNamed: (self objClassId)! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 17:24' prior: 33702860!offsetFromObjectOfInstanceVariable: aSymbol    | class offset |    class := self objClass.     offset := class offsetFromClassOfInstanceVariable: aSymbol.    offset = 0 .    ^ offset! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 17:24' prior: 33706521!offsetFromObjectOfInstanceVariable: aSymbol    | class offset |    class := self objClass.     offset := class offsetFromClassOfInstanceVariable: aSymbol.    ^ offset! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/2/2024 17:24' prior: 33702508!valueOfInstanceVariable: aSymbol    | offset |    offset := self offsetFromObjectOfInstanceVariable: aSymbol.    ^ self at: offset! !----QUIT----2024-12-02T17:52:03.312932+01:00 Pharo 8.0 - 64bit.image priorSource: 144164!!Obj methodsFor: 'method management' stamp: 'Elliot 12/9/2024 14:09' prior: 33681304!bodyOfMethod: aSelector    "Returns the block associated with the selector aSelector in the method dictionary of the class.    If the method is not found, returns nil."    ^ (self objMethodDict at: aSelector ifAbsent: [nil]).! !!Obj methodsFor: 'method management' stamp: 'AutoDeprecationRefactoring 12/9/2024 14:10' prior: 33684857!methodWithHeader: col andBody: aString	| block string resBlock |	string := self stringOfBlockBodyFromHeader: col andBody: aString.	block := Compiler new		source: string;		evaluate.	"bind superclass to the superclass of the class defining the method"	resBlock := block		value: (Obj giveClassNamed: self objSuperclassId ifAbsent: [ 666 ]).	^ resBlock! !!Obj methodsFor: 'method lookup' stamp: 'Elliot 12/9/2024 14:14' prior: 33684606!lookup: aSelector    "Return the method-body associated with aSelector in this class or its superclasses.    If no method is found, return nil."    | methodOrNil |    methodOrNil := (self objMethodDict at: aSelector ifAbsent: [nil]).    ^ methodOrNil ifNil: [        (self objSuperclass isNil)            ifTrue: [nil]            ifFalse: [self objSuperclass lookup: aSelector]    ].! !!Obj methodsFor: 'message passing' stamp: 'Elliot 12/9/2024 14:15' prior: 33691086!send: selector withArguments: arguments    "Send the message with the selector to the receiver.     The method is looked up starting in the class of the receiver."    ^ self basicSend: selector withArguments: arguments from: self objClass.! !!Obj methodsFor: 'message passing' stamp: 'Elliot 12/9/2024 14:21' prior: 33692015!super: selector withArguments: arguments from: aSuperclass    "Send a message to the receiver starting lookup in a superclass.    selector: The method name to invoke.    arguments: The arguments to pass to the method.    aSuperclass: The superclass where the lookup starts."    ^ self basicSend: selector withArguments: arguments from: aSuperclass.! !!Obj methodsFor: 'message passing' stamp: 'Elliot 12/9/2024 14:27' prior: 33691426!sendError: selector withArgs: arguments    "Send an error message to the receiver, wrapping arguments into an array with the selector as the first argument.    If no error handling is defined, raise a Pharo error as a fallback."    ^ self send: #error withArguments: {(Array with: selector) , arguments}.! !!Obj methodsFor: 'message passing' stamp: 'Elliot 12/9/2024 14:27' prior: 33709407!sendError: selector withArgs: arguments    "send error wrapping arguments into an array with the selector as first argument. Instead of an array we should create a message object."    ^ self send: #error withArguments:  {(arguments copyWithFirst: selector)}! !!Obj methodsFor: 'message passing' stamp: 'Elliot 12/9/2024 14:29' prior: 33680465!basicSend: selector withArguments: arguments from: aClass    "Execute the method found starting from aClass and whose name is selector.    The core of the sending a message, reused for both a normal send or a super one."    | methodOrNil |    methodOrNil := (aClass lookup: selector).    ^ methodOrNil        ifNotNil: [ methodOrNil valueWithArguments: (Array with: self) , arguments ]        ifNil: [ self sendError: selector withArgs: arguments ].! !!Obj methodsFor: 'message passing' stamp: 'Elliot 12/9/2024 14:30' prior: 33709804!sendError: selector withArgs: arguments    "Send an error message to the receiver, wrapping arguments into an array with the selector as the first argument.    If no error handling is defined, raise a Pharo error as a fallback."    ^ self send: #error withArguments: {(Array with: selector) , arguments}.! !!Obj methodsFor: 'message passing' stamp: 'Elliot 12/9/2024 14:31' prior: 33710698!sendError: selector withArgs: arguments    "send error wrapping arguments into an array with the selector as first argument. Instead of an array we should create a message object."    ^ self send: #error withArguments:  {(arguments copyWithFirst: selector)}! !!Obj methodsFor: 'message passing' stamp: 'Elliot 12/9/2024 14:33' prior: 33710152!basicSend: selector withArguments: arguments from: aClass    "Execute the method found starting from aClass and whose name is selector.    The core of sending a message, reused for both a normal send or a super one."    | methodOrNil |    methodOrNil := aClass lookup: selector.    ^ methodOrNil        ifNotNil: [ methodOrNil valueWithArguments: (Array with: self) , arguments ]        ifNil: [ self sendError: selector withArgs: arguments ].! !!Obj methodsFor: 'method lookup' stamp: 'Elliot 12/9/2024 14:41' prior: 33708150!lookup: selector    "Cherche la méthode nommée <selector> en partant de la classe actuelle.    Si la méthode n'est pas trouvée dans la classe courante, elle est recherchée dans la classe parente (superclass).    self est un objClass."    | method |    "1. Recherche directe de la méthode dans le dictionnaire des méthodes"    method := self objMethodDict at: selector ifAbsent: [nil].    "2. Si la méthode est trouvée, on la retourne"    method ifNotNil: [^method].    "3. Recherche dans la classe parente si la méthode n'est pas trouvée"    ^ (self objSuperclass isNil)         ifTrue: [nil]         ifFalse: [self objSuperclass lookup: selector].! !!Obj methodsFor: 'method lookup' stamp: 'Elliot 12/9/2024 14:42' prior: 33711982!lookup: selector    "Cherche la méthode nommée <selector> en partant de la classe actuelle.     La recherche est effectuée pour un message envoyé à un objet de type <anObjObject>.    Si la méthode n'est pas trouvée dans la classe courante, elle est recherchée dans la classe parente (superclass).     self est un objClass."    | method superclassid |    "1. Recherche de la méthode dans le dictionnaire des méthodes de la classe actuelle"    method := self objMethodDict at: selector ifAbsent: [ nil ].    "2. Si la méthode est trouvée, on la retourne immédiatement"    method ifNotNil: [ ^method ].    "3. Si la méthode n'est pas trouvée, on regarde si la classe a une classe parente (superclass)"    superclassid := self objSuperclassId.    "4. Si la classe n'a pas de classe parente, on retourne nil, indiquant que la méthode n'est pas définie"    superclassid ifNil: [ ^nil ].    "5. Si une classe parente existe, on effectue la recherche dans la classe parente"    ^ self objSuperclass lookup: selector! !!Obj methodsFor: 'method lookup' stamp: 'Elliot 12/9/2024 14:44' prior: 33712744!lookup: selector    "Recherche la méthode associée au selector en partant de la classe actuelle. Si elle n'est pas trouvée, recherche dans la classe parente."        | method classToSearch |    "1. Initialisation de la classe à rechercher (commence avec la classe actuelle)"    classToSearch := self.    "2. Recherche de la méthode dans la classe actuelle ou ses superclasses"    [         "2.1 Vérification de la méthode dans le dictionnaire des méthodes de la classe actuelle"        method := classToSearch objMethodDict at: selector ifAbsent: [nil].                "2.2 Si la méthode est trouvée, la retourner"        method ifNotNil: [ ^method ].                "2.3 Si la méthode n'est pas trouvée, passer à la classe parente"        classToSearch := classToSearch objSuperclass.    ]     whileTrue: [ classToSearch isNotNil ].        "3. Si la méthode n'est pas trouvée dans la chaîne de classes, retourner nil"    ^ nil.! !!Obj methodsFor: 'method lookup' stamp: 'Elliot 12/9/2024 14:46' prior: 33713875!lookup: selector    "Cherche la méthode nommée <selector> dans la classe actuelle et ses superclasses.    Si la méthode n'est pas trouvée, retourne nil."        | method parentClass |    "1. Recherche de la méthode dans le dictionnaire des méthodes de la classe actuelle"    method := self objMethodDict at: selector ifAbsent: [nil].    "2. Si la méthode est trouvée, la retourner immédiatement"    method ifNotNil: [ ^method ].    "3. Si la méthode n'est pas trouvée, on examine la classe parente"    parentClass := self objSuperclass.    "4. Si aucune classe parente n'existe, retourner nil"    parentClass ifNil: [ ^nil ].    "5. Si une classe parente existe, continuer la recherche dans la classe parente"    ^ parentClass lookup: selector.! !!Obj methodsFor: 'method lookup' stamp: 'Elliot 12/9/2024 14:48' prior: 33714928!lookup: selector    "Cherche la méthode désignée par <selector> dans la classe actuelle et ses superclasses.     Si la méthode n'est pas trouvée, retourne nil."        | method superclassid |    "1. On tente de récupérer la méthode depuis le dictionnaire des méthodes de la classe actuelle"    method := self objMethodDict at: selector ifAbsent: [nil].    "2. Si la méthode est trouvée, on la retourne immédiatement"    method ifNotNil: [ ^method ].    "3. Si la méthode n'est pas dans la classe actuelle, on vérifie la classe parente"    superclassid := self objSuperclassId.    "4. Si la classe n'a pas de classe parente, cela signifie qu'il n'y a plus d'endroit où chercher"    superclassid ifNil: [ ^nil ].    "5. Si une classe parente existe, la recherche continue dans celle-ci"    ^ self objSuperclass lookup: selector.! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/9/2024 14:54' prior: 33702293!offsetFromClassOfInstanceVariable: aSymbol    "Cherche la variable d'instance nommée <aSymbol> dans la classe actuelle et ses superclasses.    Si la variable n'est pas trouvée, une erreur est levée."        | ivList offset |        "1. Recherche de la variable d'instance dans la classe actuelle"    ivList := self objIVs.    offset := ivList indexOf: aSymbol.        "2. Si la variable n'est pas trouvée dans la classe actuelle"    offset = 0 ifTrue: [        "3. Si la variable n'est pas trouvée, on cherche dans la classe parente"        self objSuperclass ifNil: [            "Si aucune classe parente n'existe, on lève une erreur"            Error signal: 'Instance variable not found'.        ] ifNotNil: [            "Si une classe parente existe, on effectue la recherche dans la classe parente"            ^ self objSuperclass offsetFromClassOfInstanceVariable: aSymbol.        ].    ].        "4. Si la variable a été trouvée dans la classe actuelle, on retourne l'index"    ^ offset.! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/9/2024 14:55' prior: 33716736!offsetFromClassOfInstanceVariable: aSymbol    | ivList  |    ivList := self objIVs.     ^ ivList := ivList indexOf: aSymbol .! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/9/2024 14:57' prior: 33706795!offsetFromObjectOfInstanceVariable: aSymbol    "Cherche l'offset de la variable d'instance <aSymbol> dans l'objet actuel ou dans ses superclasses.    Si la variable d'instance n'existe pas, une erreur est levée."    | class offset |        "Commence par chercher dans la classe actuelle."    class := self objClass.     offset := class offsetFromClassOfInstanceVariable: aSymbol.        "Si la variable d'instance n'est pas trouvée dans la classe actuelle"    offset ifNil: [        "Vérifie si la classe a une classe parente (superclass)."        self objSuperclass ifNil: [            "Si aucune classe parente et la variable n'est pas trouvée, lever une erreur."            Error signal: 'Instance variable not found'.        ] ifNotNil: [            "Si une classe parente existe, chercher dans la classe parente."            offset := self objSuperclass offsetFromClassOfInstanceVariable: aSymbol.            "Si la variable n'est pas trouvée dans la classe parente"            offset ifNil: [                Error signal: 'Instance variable not found'.            ].        ].    ].        "Retourne l'offset si la variable est trouvée."    ^ offset.! !!Obj methodsFor: 'iv management' stamp: 'Elliot 12/9/2024 14:58' prior: 33718064!offsetFromObjectOfInstanceVariable: aSymbol    "Receiver should be: anObjInstance. Returns the offset of the instance variable represented     by aSymbol. Raises an error if the variable does not exist."    | class offset |    class := self objClass. "Obtenir la classe de l'instance"    offset := class offsetFromClassOfInstanceVariable: aSymbol. "Obtenir l'offset"    offset = 0 ifTrue: [self error: 'Instance variable does not exist'].    ^ offset! !TestCase subclass: #ObjPointTest	instanceVariableNames: ''	classVariableNames: ''	package: 'ObjVSkeleton'!!ObjPointTest methodsFor: 'as yet unclassified' stamp: 'Elliot 12/9/2024 15:44'!testAPoint | objclass pointClass aPoint |objclass := Obj giveClassNamed: #ObjClass .objclass send: #newwithArguments: #((#name: #ObjPoint #iv: #(#x y) #superclass: #ObjObject)).pointClass := Obj giveClassNamed: #ObjPoint .aPoint := pointClass send: #new withArguments: #((#x: 24 #y: 6)).aPoint send: #getIV withArguments: #(#x).aPoint send: #setIV withArguments: #(#x 25).aPoint send: #getIV withArguments: #(#x).! !!ObjPointTest methodsFor: 'as yet unclassified' stamp: 'Elliot 12/9/2024 15:49'!testColoredPoint	| coloredPointClass aColoredPoint |	coloredPointClass := (Obj ObjClass)						 	send: #new 							withArguments: #((#name: #ObjColoredPoint 							           		   #iv: #(#color) 							            	  #superclass: #ObjPoint)).	aColoredPoint := coloredPointClass send: #new withArguments: #((#x: 24 #y: 6 #color: #blue)).		"first messages sent"	self assert: (aColoredPoint send: #getIV withArguments: #(#x)) = 24.	aColoredPoint send: #setIV withArguments: #(#x 25).	self assert: (aColoredPoint send: #getIV withArguments: #(#x)) = 25.	self assert: (aColoredPoint send: #getIV withArguments: #(#color)) = #blue.		"adding some methods"	coloredPointClass 		addUnaryMethod: #giveColor		withBody: 'objself send: #getIV withArguments: #(#color)'.	coloredPointClass 		addMethod: #setColor		args: 'col'		withBody:' objself send: #setIV withArguments: (Array with: #color with: col)'.	coloredPointClass addUnaryMethod: #display		withBody:  			'objself super: #display withArguments: #() from: superClassOfClassDefiningTheMethod.			Transcript cr;				show: '' with Color = ''.			Transcript show: (objself send: #giveColor withArguments: #()) printString;				cr'.	self assert: (aColoredPoint send: #giveColor withArguments: #()) = #blue.		self assert: (aColoredPoint send: #givex withArguments: #()) = 25.		aColoredPoint send: #display withArguments: #().! !!ObjExampleTest methodsFor: 'as yet unclassified' stamp: 'Elliot 12/9/2024 15:54'!testPoint    |point|    point := (Obj ObjPoint) send: #new withArguments: #(#(#x: 24 #y: 6)).    self assert: (point send: #getIV withArguments: #(#x)) = 24.    point send: #setIV withArguments: #(#x 25).    self assert: (point send: #getIV withArguments: #(#x)) = 25.    Obj ObjPoint        addUnaryMethod: #givex        withBody: 'objself valueOfInstanceVariable: #x '.    Obj ObjPoint        addUnaryMethod: #display        withBody:            'Transcript cr;                show: ''aPoint with x = ''.            Transcript show: (objself send: #givex withArguments: #()) printString;                cr'.    self assert: (point send: #givex withArguments: #()) = 25.    point send: #display withArguments: #().! !!ObjPointTest methodsFor: 'as yet unclassified' stamp: 'Elliot 12/9/2024 15:54'!testAbstractMetaclassExample	self should: [Obj ObjAbstractClass send: #new withArguments: #(#(#x: 24 #y: 6))] raise: Error.! !!ObjPointTest methodsFor: 'as yet unclassified' stamp: 'Elliot 12/9/2024 15:54'!testAbstractMetaclassExampleWithConcreteSubclass	self shouldnt: [Obj ObjPoint send: #new withArguments: #(#(#x: 24 #y: 6))]		raise: Error! !----SNAPSHOT----2024-12-09T16:08:19.442676+01:00 Pharo 8.0 - 64bit.image priorSource: 152756!----SNAPSHOT----2024-12-09T16:08:23.526322+01:00 Pharo 8.0 - 64bit.image priorSource: 168726!----SNAPSHOT----2024-12-09T16:31:55.426782+01:00 Pharo 8.0 - 64bit.1.image priorSource: 168821!